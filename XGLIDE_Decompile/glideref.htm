
<!-- saved from url=(0054)https://www.gamers.org/dEngine/xf3D/glide/glideref.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"></head>
<body link="#00008b" vlink="#8b0000">
<p align="CENTER">
<font size="2"><br></font>
</p>
<p align="CENTER">
<font size="7"><b><br></b></font>
</p>
<p align="CENTER">
<font size="7"><b><br></b></font>
</p>
<p align="CENTER">
<font size="7"><b>Glide 2.2 Reference Manual</b></font>
</p>
<p align="CENTER">
<font size="7"><br></font>
</p>
<p align="CENTER">
Document Release 015
</p>
<p align="CENTER">
22 May 1997
</p>
<p align="CENTER">
<font size="2"><font size="4">Copyright </font>ã<font size="4"> 1995</font>-<font size="4">1997 3Dfx Interactive, Inc. </font></font>
</p>
<p align="CENTER">
All Rights Reserved
</p>
<p align="CENTER">
<br>
</p>
<p align="CENTER">
<br>
</p>
<p align="CENTER">
<font size="4"><b>3Dfx Interactive, Inc.</b></font>
</p>
<p align="CENTER">
4435 Fortran Drive
</p>
<p align="CENTER">
San Jose, CA 95134
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><b><br></b></font>
</p>
<h1>
Introduction
</h1>
<p>
This document is the official programming reference for version 2.0 of 3Dfx Interactive Glide Rasterization Library. The Glide Library is a low-level rendering and state management sub-routine library that serves as a thin layer over the register level int
erface of the Voodoo Graphics™ family of graphics hardware. Glide permits easy and efficient implementation of 3D rendering libraries, games, and drivers on the Voodoo Graphics hardware. Glide only implements operations that are natively supported by the V
oodoo Graphics family of graphics hardware. Higher level operations are located in the Glide Utility Library, which is currently part of Glide.
</p>
<p>
Glide serves three primary purposes:
</p>
<ul><li>
It relieves programmers from hardware specific issues such as timing, maintaining register shadows, and working with hard-coded register constants and offsets.
</li><li>
It defines an abstraction of the graphics hardware to facilitate ease of software porting.
</li><li>
It acts as a delivery vehicle for sample source code providing in-depth optimizations.</li></ul>
<p>
By abstracting the low level details of interfacing with the Voodoo Graphics family of graphics hardware into a set of C-callable APIs, Glide allows developers targeting the Voodoo Graphics family of graphics hardware to avoid working with hardware registe
rs and memory directly, enabling faster development and lower probability of bugs. Glide also handles mundane and error prone chores, such as initialization and shutdown.
</p>
<p>
Glide currently consists of Glide APIs as well as Glide Utility APIs. All Glide APIs begin with the gr prefix, all Glide Utility APIs being with the gu prefix. Glide Utility APIs do not directly communicate with hardware registers; they are strictly layere
d on Glide APIs. Therefore, their functionality could be performed just as easily by application code. Glide Utility APIs are included in Glide for convenience.
</p>
<p>
Voodoo Graphics consists of a Pixel<i>fx</i> chip which performs pixel rendering operations and manages the video frame buffer, and one or more Texel<i>fx</i> chips which perform texture mapping operations. Each Texel<i>fx</i> chip contains one Texture Mapping Unit, or TMU. Th
e term TMU is used throughout the rest of this manual.
</p>
<p>
Voodoo Graphics was internally code-named SST-1, or SST for short. Some of the API names, e.g. grSstWinOpen, still reflect the internal code name. In general, Voodoo Graphics is used in the API description, but SST is used in the API names.
</p>
<h1>
Base Types
</h1>
<p>
All 3Dfx Interactive programming libraries use a common set of platform-independent signed and unsigned types. These types can be found in 3dfx.h and are described in the table below:
</p>
<table width="412" border="1" frame="BOX" rules="ALL">
<colgroup><col width="98"><col width="143"><col width="171"></colgroup><tbody><tr>
<td width="98" valign="TOP">
<p>
<b>Type Name</b>
</p></td>
<td width="143" valign="TOP">
<p>
<b>Format</b>
</p></td>
<td width="171" valign="TOP">
<p>
<b>ANSI C type</b>
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxI8
</p></td>
<td width="143" valign="TOP">
<p>
8-bit signed
</p></td>
<td width="171" valign="TOP">
<p>
signed char
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxU8
</p></td>
<td width="143" valign="TOP">
<p>
8-bit unsigned 
</p></td>
<td width="171" valign="TOP">
<p>
unsigned char
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxU16
</p></td>
<td width="143" valign="TOP">
<p>
16-bit unsigned
</p></td>
<td width="171" valign="TOP">
<p>
unsigned short int
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxI16
</p></td>
<td width="143" valign="TOP">
<p>
16-bit signed
</p></td>
<td width="171" valign="TOP">
<p>
signed short int
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxU32
</p></td>
<td width="143" valign="TOP">
<p>
32-bit unsigned
</p></td>
<td width="171" valign="TOP">
<p>
unsigned long int
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxI32
</p></td>
<td width="143" valign="TOP">
<p>
32-bit signed value
</p></td>
<td width="171" valign="TOP">
<p>
signed long int
</p></td>
</tr>
<tr>
<td width="98" valign="TOP">
<p>
FxBool
</p></td>
<td width="143" valign="TOP">
<p>
32-bit signed
</p></td>
<td width="171" valign="TOP">
<p>
long int
</p></td>
</tr>
</tbody></table>
<h2>
Predefined Constants
</h2>
<p>
Glide predefines several constants and is also dependent upon several externally defined constants. These are documented in full in glide.h.
</p>
<h1>
API Reference
</h1>
<p>
The following is an API reference that lists the APIs provided by Glide, their purpose, usage, parameters, and notes describing their implementation.
</p>
<h2>
grAADrawLine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAADrawLine – draw an anti-aliased line segment</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAADrawLine(GrVertex *va, GrVertex *vb)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">va, vb	Vertices describing the line segment.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide draws an anti-aliased line segment between the two vertices by setting up the alpha iterator so that it represents pixel coverage. grAlphaCombine must select iterated alpha and grAlphaBlendFunction should select GR_BLEND_SRC_ALPHA, GR_BLEND_ONE_MINUS
_SCR_ALPHA as the RGB blend functions and GR_BLEND_ZERO, GR_BLEND_ZERO as the alpha blend functions if sorting from back to front and GR_BLEND_ALPHA_SATURATE, GR_BLEND_ONE as the RGB blend functions and GR_BLEND_SATURATE, GR_BLEND_ONE as the alpha blend fu
nctions if sorting from front to back. Opaque anti-aliased primitives <b><u>must</u></b> set alpha=255 in the vertex data. Transparent anti-aliased primitives are drawn by setting alpha to values less than 255; this alpha value is multiplied by the pixel coverage to obt
ain the final alpha value for alpha blending.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Resultant lines will be somewhat ‘fatter’ than expected. </font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAADrawPoint, grAADrawTriangle, grAlphaBlendFunction, grAlphaCombine</font>
</p>
<h2>
grAADrawPoint
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAADrawPoint – draw an anti-aliased point</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAADrawPolygon(GrVertex *p)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">p	The point to draw.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide draws an anti-aliased point by rendering four pixels and setting up the alpha iterator so that it represents pixel coverage. grAlphaCombine must select iterated alpha and grAlphaBlendFunction should select GR_BLEND_SRC_ALPHA, GR_BLEND_ONE_MINUS_SCR_A
LPHA as the RGB blend functions and GR_BLEND_ZERO, GR_BLEND_ZERO as the alpha blend functions if sorting from back to front and GR_BLEND_ALPHA_SATURATE, GR_BLEND_ONE as the RGB blend functions and GR_BLEND_SATURATE, GR_BLEND_ONE as the alpha blend function
s if sorting from front to back. Opaque anti-aliased primitives <b><u>must</u></b> set alpha=255 in the vertex data. Transparent anti-aliased primitives are drawn by setting alpha to values less than 255; this alpha value is multiplied by the pixel coverage to obtain th
e final alpha value for alpha blending.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
See Also
</p>
<p>
<font size="2">grAADrawLine, grAADrawTriangle, grAlphaBlendFunction, grAlphaCombine</font>
</p>
<h2>
grAADrawPolygon
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAADrawPolygon – draw an anti-aliased convex polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAADrawPolygon(int nVerts, const int ilist[], const GrVertex vlist[])</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">ilist	Array of indices into <i>vlist</i>.</font>
</p>
<p>
<font size="2">vlist	Array of vertices indexed by <i>ilist</i>.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide draws an anti-aliased polygon from an array of vertices and indices into this array.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See notes on grAADrawTriangle for the limitations of this routine. Further limitations are:</font>
</p>
<ul><li>
All exterior polygon edges are anti-aliased
</li><li>
Only convex polygons are drawn properly.</li></ul>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAADrawPolygonVertexList, grAADrawTriangle</font>
</p>
<h2>
grAADrawPolygonVertexList
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAADrawPolygonVertexList – draw an anti-aliased convex polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAADrawPolygonVertexList(int nVerts, const GrVertex vlist[])</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">vlist	Array of vertices in the polygon.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide draws an anti-aliased polygon from an array of vertices.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See notes on grAADrawTriangle for the limitations of this routine. Further limitations are:</font>
</p>
<ul><li>
All exterior polygon edges are anti-aliased.
</li><li>
Only convex polygons are drawn properly.
</li><li>
Vertices are drawn in the order presented in vlist[].</li></ul>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAADrawPolygon, grAADrawTriangle, grAADrawLine, grAADrawPoint</font>
</p>
<h2>
grAADrawTriangle
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gr<b><font size="1">AADrawTriangle</font></b> – draw an anti-aliased triangle</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAADrawTriangle( GrVertex *a, GrVertex *b, GrVertex *c,<br>FxBool antialiasAB, FxBool antialiasBC, FxBool antialiasCA)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">a	Vertex a.</font>
</p>
<p>
<font size="2">b	Vertex b.</font>
</p>
<p>
<font size="2">c	Vertex c.</font>
</p>
<p>
<font size="2">antialiasAB	If FXTRUE, anti-alias the AB edge.</font>
</p>
<p>
<font size="2">antialiasBC	If FXTRUE, anti-alias the BC edge.</font>
</p>
<p>
<font size="2">antialiasCA	If FXTRUE, anti-alias the CA edge.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide draws a triangle with the specified edges anti-aliased by setting up the alpha iterator so that it represents pixel coverage. grAlphaCombine must select iterated alpha and grAlphaBlendFunction should select GR_BLEND_SRC_ALPHA, GR_BLEND_ONE_MINUS_SCR_
ALPHA as the RGB blend functions and GR_BLEND_ZERO, GR_BLEND_ZERO as the alpha blend functions if sorting from back to front and GR_BLEND_ALPHA_SATURATE, GR_BLEND_ONE as the RGB blend functions and GR_BLEND_SATURATE, GR_BLEND_ONE as the alpha blend functio
ns if sorting from front to back. Opaque anti-aliased primitives <b><u>must</u></b> set alpha=255 in the vertex data. Transparent anti-aliased primitives are drawn by setting alpha to values less than 255; this alpha value is multiplied by the pixel coverage to obtain t
he final alpha value for alpha blending.</font>
</p>
<p>
Notes
</p>
<p>
<font size="2">If there is a steep gradient in a particular color space (i.e., green goes from 255.0 to 0.0 in a small number of pixels), then there will be visual anomalies at the edges of the resultant anti-aliased triangle. The workaround for this ‘feature’ is to redu
ce the gradient by increasing small color components and decreasing large ones. This can be demonstrated by changing the values of maxColor and minColor in test25 of the Glide distribution. Note that this ‘feature’ is only present when the color combine mo
de includes iterated RGB or alpha as one of the parameters in the final color.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAADrawLine, grAADrawPoint, grAlphaBlendFunction, grAlphaCombine</font>
</p>
<h2>
grAlphaBlendFunction
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gr<b><font size="1">AlphaBlendFunction</font></b> – specify the alpha blending function</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAlphaBlendFunction(	GrAlphaBlendFnc_t rgb_sf,</font>
</p>
<p>
<font size="2">	GrAlphaBlendFnc_t rgb_df,</font>
</p>
<p>
<font size="2">	GrAlphaBlendFnc_t alpha_sf,</font>
</p>
<p>
<font size="2">	GrAlphaBlendFnc_t alpha_df </font>
</p>
<p>
<font size="2">)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">rgb_sf	Specifies the red, green, and blue source blending factors. Nine symbolic constants are accepted:</font>
</p>
<center><table align="CENTER" width="230" border="1" frame="BOX" rules="ROWS">
<colgroup><col width="230"></colgroup><tbody><tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ZERO</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ALPHA_SATURATE</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><i><br></i></font>
</p>
<p>
<font size="2"><i>rgb_df</i>	Specifies the red, green, and blue destination blending factors. Eight symbolic constants are accepted:</font>
</p>
<center><table align="CENTER" width="230" border="1" frame="BOX" rules="ROWS">
<colgroup><col width="230"></colgroup><tbody><tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ZERO</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_ALPHA</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">alpha_sf	Specifies the alpha source blending factor. Nine symbolic constants are accepted: </font>
</p>
<center><table align="CENTER" width="230" border="1" frame="BOX" rules="ROWS">
<colgroup><col width="230"></colgroup><tbody><tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ZERO</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ALPHA_SATURATE</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><i><br></i></font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><i>alpha_df</i>	Specifies the alpha destination blending factor. Eight symbolic constants are accepted:</font>
</p>
<center><table align="CENTER" width="230" border="1" frame="BOX" rules="ROWS">
<colgroup><col width="230"></colgroup><tbody><tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ZERO</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_COLOR</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_ALPHA</font>
</p></td>
</tr>
<tr>
<td width="230" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_ALPHA</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Alpha blending blends the RGBA values for rendered pixels (source) with the RGBA values that are already in the frame buffer (destination). grAlphaBlendFunction defines the operation of blending. rgb_sf and <i>alpha_sf</i> specifies which of nine methods is used 
to scale the source color and alpha components. rgb_df and <i>alpha_df</i> specifies which of eight methods is used to scale the destination color and alpha components.</font>
</p>
<p>
<font size="2">Alpha blending is defined by the equations:</font>
</p>
<center><table align="CENTER" width="145" frame="VOID" rules="NONE">
<colgroup><col width="145"></colgroup><tbody><tr>
<td width="145" valign="TOP">
<p>
<font size="2"><i>R</i> = min (255, <i>R<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> <i>s<font size="1"><sub>R</sub></font></i><font size="1"><sub></sub></font> + <i>R<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> <i>d<font size="1"><sub>R</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="145" valign="TOP">
<p>
<font size="2"><i>G</i> = min (255, <i>G<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> <i>s<font size="1"><sub>G</sub></font></i><font size="1"><sub></sub></font> + <i>G<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> <i>d<font size="1"><sub>G</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="145" valign="TOP">
<p>
<font size="2"><i>B</i> = min (255, <i>B<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> <i>s<font size="1"><sub>B</sub></font></i><font size="1"><sub></sub></font> + <i>B<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> <i>d<font size="1"><sub>B</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="145" valign="TOP">
<p>
<font size="2"><i>A</i> = min (255, <i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> <i>s<font size="1"><sub>A</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> <i>d<font size="1"><sub>A</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2">where <i>R<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>G<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>B<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> are the source color and alpha components, <i>R<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>G<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>B<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> are the destination color and alpha components, <i>s<font size="1"><sub>R</sub></font></i><font size="1"><sub></sub></font>, <i>s<font size="1"><sub>G</sub></font></i><font size="1"><sub></sub></font>, <i>s<font size="1"><sub>B</sub></font></i><font size="1"><sub></sub></font> <i>s<font size="1"><sub>A</sub></font></i><font size="1"><sub></sub></font> are the source blending factors, and <i>d<font size="1"><sub>R</sub></font></i><font size="1"><sub></sub></font>, <i>d<font size="1"><sub>G</sub></font></i><font size="1"><sub></sub></font>, <i>d<font size="1"><sub>B</sub></font></i><font size="1"><sub></sub></font>, <i>d<font size="1"><sub>A</sub></font></i><font size="1"><sub></sub></font> are the destination blending factors.</font>
</p>
<p>
<font size="2">The blending factors are as follows:</font>
</p>
<center><table align="CENTER" width="306" border="1" frame="BOX" rules="ALL">
<colgroup><col width="175"><col width="132"></colgroup><tbody><tr>
<td width="175" valign="TOP">
<p>
<font size="2"><b>Blending Factor</b></font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2"><b>Component Blend Factor</b></font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ZERO</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">1</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_COLOR</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_COLOR</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">1 – <i>C<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_COLOR</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_COLOR</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">1 – <i>C<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_SRC_ALPHA</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_SRC_ALPHA</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_DST_ALPHA</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ONE_MINUS_DST_ALPHA</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="175" valign="TOP">
<p>
<font size="2">GR_BLEND_ALPHA_SATURATE</font>
</p></td>
<td width="132" valign="TOP">
<p>
<font size="2">min (<i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> / 255, 1 – <i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> / 255)</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">where <i>C<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> and <i>C<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> are the corresponding <i>R<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>G<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>B<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font>, <i>A<font size="1"><sub>s</sub></font></i><font size="1"><sub></sub></font> and <i>R<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>G<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>B<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font>, <i>A<font size="1"><sub>d</sub></font></i><font size="1"><sub></sub></font> components respectively.</font>
</p>
<p>
<font size="2">To disable alpha blending, call </font>
</p>
<p align="CENTER">
<font size="2">grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ZERO, GR_BLEND_ONE, GR_BLEND_ZERO)</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The source of incoming alpha and color are determined by grAlphaCombine and grColorCombine respectively.</font>
</p>
<p>
<font size="2">Alpha blending that requires a destination alpha is mutually exclusive of either depth buffering or triple buffering. Attempting to use GR_BLEND_DST_ALPHA, GR_BLEND_ONE_MINUS_DST_ALPHA, or GR_BLEND_ALPHA_SATURATE when depth buffering or triple buffering ar
e enabled will have undefined results.</font>
</p>
<p>
<font size="2">For alpha source and destination blend function factor parameters, Voodoo Graphics supports only GR_BLEND_ZERO and GR_BLEND_ONE.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAADrawLine, grAADrawPoint, grAADrawTriangle, grAlphaCombine, grColorCombine</font>
</p>
<h2>
grAlphaCombine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAlphaCombine – configure the alpha combine unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAlphaCombine(	GrCombineFunction_t func, </font>
</p>
<p>
<font size="2">	GrCombineFactor_t factor,</font>
</p>
<p>
<font size="2">	GrCombineLocal_t local, </font>
</p>
<p>
<font size="2">	GrCombineOther_t other, </font>
</p>
<p>
<font size="2">	FxBool invert </font>
</p>
<p>
<font size="2">	)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">func	Specifies the function used in source alpha generation. Valid parameters are described below. The combine function names are prefixed with the string “GR_COMBINE_FUNCTION_”: e.g. GR_COMBINE_FUNCTION_ZERO or GR_COMBINE_FUNCTION_BLEND_LOCAL.</font>
</p>
<center><table align="CENTER" width="352" border="1" frame="BOX" rules="ALL">
<colgroup><col width="234"><col width="117"></colgroup><tbody><tr>
<td width="234" valign="TOP">
<p>
<font size="2"><b>Combine Function</b></font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><b>Computed Alpha</b></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">ZERO</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">LOCAL</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">LOCAL_ALPHA</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER</font>
</p><p>
<font size="2">BLEND_OTHER</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER_ADD_LOCAL</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER_MINUS_LOCAL</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *(<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">BLEND</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *(<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º <i>f</i> *<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + (1– <i>f</i>)*<i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *(<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">BLEND_LOCAL</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *(– <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º (1– <i>f</i>) *<i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="234" valign="TOP">
<p>
<font size="2">SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="117" valign="TOP">
<p>
<font size="2"><i>f</i> *(– <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">factor	Specifies the scaling factor used in alpha generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="352" border="1" frame="BOX" rules="ALL">
<colgroup><col width="248"><col width="103"></colgroup><tbody><tr>
<td width="248" valign="TOP">
<p>
<font size="2"><b>Combine Factor</b></font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2"><b>Scale Factor (<i>f</i>)</b></font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_NONE</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">Unspecified</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ZERO</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_OTHER_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_TEXTURE_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2"><i>A<sub>texture</sub></i><sub></sub> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">1</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_OTHER_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_TEXTURE_ALPHA</font>
</p></td>
<td width="103" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>texture</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">local	Specifies the local alpha used in source alpha generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="352" border="1" frame="BOX" rules="ALL">
<colgroup><col width="197"><col width="155"></colgroup><tbody><tr>
<td width="197" valign="TOP">
<p>
<font size="2"><b>Local Combine Source</b></font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2"><b>Local Alpha (<i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</b></font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_NONE</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Unspecified alpha</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_ITERATED</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Iterated vertex alpha</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_CONSTANT</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Constant alpha</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_DEPTH</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">High 8 bits from iterated vertex <i>z</i></font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">other	Specifies the other alpha used in source alpha generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="352" border="1" frame="BOX" rules="ALL">
<colgroup><col width="197"><col width="155"></colgroup><tbody><tr>
<td width="197" valign="TOP">
<p>
<font size="2"><b>Other Combine Source</b></font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2"><b>Other Alpha (<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>)</b></font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_NONE</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Unspecified alpha</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_ITERATED</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Iterated vertex alpha</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_TEXTURE</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Alpha from texture map</font>
</p></td>
</tr>
<tr>
<td width="197" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_CONSTANT</font>
</p></td>
<td width="155" valign="TOP">
<p>
<font size="2">Constant alpha</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">invert	Specifies whether the generated alpha should be bitwise inverted as a final step.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grAlphaCombine configures the alpha combine unit of the graphics subsystem’s hardware pipeline. This provides a low level mechanism for controlling all rendering modes within the hardware without manipulating individual register bits. The alpha combine uni
t computes the source alpha for the remainder of the rendering pipeline. The default mode is </font>
</p>
<p>
<font size="1">grAlphaCombine( GR_COMBINE_FUNCTION_SCALE_OTHER, GR_COMBINE_FACTOR_ONE, 	GR_COMBINE_LOCAL_NONE, GR_COMBINE_OTHER_CONSTANT, FXFALSE);</font>
</p>
<p>
<font size="1"><br></font>
</p>
<p>
<font size="2">The alpha combine unit computes the function specified by the combine function on the inputs specified by the local combine source, other combine source, and the combine scale factor. The result is clamped to [0..255], and then a bitwise inversion may be a
pplied, controlled by the <i>invert</i> parameter.</font>
</p>
<p>
<font size="2">The constant color parameters are the colors passed to <b><font size="1">grConstantColorValue</font></b>. If the texture has no alpha component, then texture alpha is 255.</font>
</p>
<p>
<font size="2">grAlphaCombine also keeps track of required vertex parameters for the rendering routines. GR_COMBINE_FACTOR_NONE, GR_COMBINE_LOCAL_NONE and GR_COMBINE_OTHER_NONE are provided to indicate that no parameters are required. Currently they are the same as GR_CO
MBINE_FACTOR_ZERO, GR_COMBINE_LOCAL_CONSTANT, and GR_COMBINE_OTHER_CONSTANT respectively.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The local alpha value specified by the <i>local</i> parameter and the other alpha value specified by the <i>other</i> parameter are used by the color combine unit.</font>
</p>
<p>
<font size="2">Inverting the bits in a color is the same as computing (1.0 – color) for floating point color values in the range [0..1] or (255 – color) for 8-bit color values in the range [0..255].</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grColorCombine, grConstantColorValue, grDrawTriangle</font>
</p>
<h2>
grAlphaControlsITRGBLighting
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grAlphaControlsITRGBLighting – enables/disables alpha controlled lighting</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAlphaControlsITRGBLighting( FxBool enable )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">enable	Specifies whether the mode is enabled or disabled.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">When enabled, the normal color combine controls for local color (<i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) are overridden, and the most significant bit of texture alpha (<i>A<font size="1"><sub>texture</sub></font></i><font size="1"><sub></sub></font>) selects between iterated vertex RGB and the constant color set by <b><font size="1">grConstantColorValue</font></b>. By default, alpha cont
rolled lighting mode is disabled.</font>
</p>
<center><table align="CENTER" width="459" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="134"><col width="171"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2"><b>Value of <i>enable</i></b><i></i></font>
</p></td>
<td width="134" valign="TOP">
<p>
<font size="2"><b>MSB of Alpha Channel</b></font>
</p></td>
<td width="171" valign="TOP">
<p>
<b>Color Combine Local Color</b>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
FXTRUE
</p></td>
<td width="134" valign="TOP">
<p>
0
</p></td>
<td width="171" valign="TOP">
<p>
Iterated RGB
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
FXTRUE
</p></td>
<td width="134" valign="TOP">
<p>
1
</p></td>
<td width="171" valign="TOP">
<p>
<font size="1"><b>grConstantColorValue</b></font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
FXFALSE
</p></td>
<td width="134" valign="TOP">
<p>
0
</p></td>
<td width="171" valign="TOP">
<p>
Set by grColorCombine
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
FXFALSE
</p></td>
<td width="134" valign="TOP">
<p>
1
</p></td>
<td width="171" valign="TOP">
<p>
Set by grColorCombine
</p></td>
</tr>
</tbody></table></center>
<p>
<br>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Some possible uses for this mode are self-lit texels and specular paint. If a texture contains texels that represent self-luminous areas, such as windows, then multiplicative lighting can be disabled for these texels as follows. Choose a texture format tha
t contains one bit of alpha and set the alpha for each texel to 1 if the texel is self-lit. Set the Glide constant color to white and enabled alpha controlled lighting mode. Finally, set up texture lighting by multiplying the texture color by iterated RGB 
where iterated RGB is the <i>local</i> color in the color combine unit. When a texel’s alpha is 0, the texture color will be multiplied by the local color which is iterated RGB. This applies lighting to the texture. When a texel’s alpha is 1, the texture color wi
ll be multiplied by the Glide constant color which was previously set to white, so no lighting is applied.</font>
</p>
<p>
<font size="2">If the color combine unit is configured to add iterated RGB to a texture for the purpose of a specular highlight, then texture alpha can be used as specular paint. In this example, the Glide constant color is set to black and iterated RGB iterates the spec
ular lighting. If a texel’s alpha is 0, the texture color will be added to iterated RGB, and specular lighting is applied to the texture. If the texel’s alpha is 1, the texture color will be added to the Glide constant color which was previously set to bla
ck, so no lighting is applied. The result is that the alpha channel in the texture controls where specular lighting is applied to the texture and specularity can be <i>painted</i> onto the texture in the alpha channel.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grColorCombine, grConstantColorValue </font>
</p>
<h2>
grAlphaTestFunction
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gr<b><font size="1">AlphaTestFunction</font></b> – specify the alpha test function</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAlphaTestFunction( GrCmpFnc_t function )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">function	The new alpha comparison function.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">The alpha test discards pixels depending on the outcome of a comparison between the incoming alpha value and a constant reference value. grAlphaTestFunction specifies the comparison function and grAlphaTestReferenceValue specifies the constant reference va
lue.</font>
</p>
<p>
<font size="2">The incoming alpha value is compared to the constant alpha test reference value using the function specified by function. If the comparison passes, the pixel is drawn, conditional on subsequent tests, such as depth buffer and chroma-key. If the comparison 
fails, the pixel is not drawn. The default function is GR_CMP_ALWAYS.</font>
</p>
<p>
<font size="2">The comparison functions are as follows:</font>
</p>
<center><table align="CENTER" width="469" border="1" frame="BOX" rules="ALL">
<colgroup><col width="102"><col width="367"></colgroup><tbody><tr>
<td width="102" valign="TOP">
<p>
<font size="2"><i><b>function</b></i></font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2"><b>Comparison Function</b></font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_NEVER</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Never passes.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_LESS</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is less than the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_EQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is equal to the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_LEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is less than or equal to the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_GREATER</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is greater than the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_NOTEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is not equal to the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_GEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the incoming alpha value is greater than or equal to the constant alpha reference value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_ALWAYS</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Always passes</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Alpha testing is performed on all pixel writes, including those resulting from scan conversion of points, lines, and triangles, and from direct linear frame buffer writes. Alpha testing is implicitly disabled during linear frame buffer writes if linear fra
me buffer bypass is enabled (see grLfbLock).</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The incoming alpha is the output of the alpha combine unit which is configured with grAlphaCombine.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine, grAlphaTestReferenceValue, grLfbLock</font>
</p>
<h2>
grAlphaTestReferenceValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gr<b><font size="1">AlphaTestReferenceValue</font></b> – specify the alpha test reference value</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grAlphaTestReferenceValue( GrAlpha_t value )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">value	The new alpha test reference value.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">The alpha test discards pixels depending on the outcome of a comparison between the pixel’s incoming alpha value and a constant reference value. grAlphaTestFunction specifies the comparison function and grAlphaTestReferenceValue specifies the constant refe
rence value. The default reference value is 0x00.</font>
</p>
<p>
<font size="2">The incoming alpha value is compared to the value using the function specified by grAlphaTestFunction. If the comparison passes, the pixel is drawn, conditional on subsequent tests such as depth buffer and chroma-key. If the comparison fails, the pixel is 
not drawn.</font>
</p>
<p>
<font size="2">Alpha testing is performed on all pixel writes, including those resulting from scan conversion of points, lines, and triangles, and from direct linear frame buffer writes. Alpha testing is implicitly disabled during linear frame buffer writes if linear fra
me buffer bypass is enabled (see grLfbLock).</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The incoming alpha is the output of the alpha combine unit which is configured with grAlphaCombine.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine, grAlphaTestFunction, grLfbLock</font>
</p>
<h2>
grBufferClear
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grBufferClear – clear the buffers to the specified values</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grBufferClear( GrColor_t color, GrAlpha_t alpha, FxU16 depth )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">color	The color value used for clearing the draw buffer.</font>
</p>
<p>
<font size="2">alpha	The alpha value used for clearing the alpha buffer (ignored if alpha buffering is not enabled, i.e. a destination alpha is not specified in grAlphaBlendFunction).</font>
</p>
<p>
<font size="2">depth	16-bit unsigned value used for clearing the depth buffer (ignored if depth buffering is not enabled).</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Clears the appropriate buffers with the given values. grClipWindow defines the area within the buffer to be cleared. Any buffers that are enabled are cleared by grBufferClear. For example, if depth buffering is enabled, the depth buffer will be cleared. If
 an application does not want a buffer to be cleared, then it should mask off writes to the buffer using grDepthMask and/or grColorMask as appropriate.</font>
</p>
<p>
<font size="2">Although color, alpha, and depth parameters are always specified, the parameters actually used will depend on the current configuration of the hardware; the irrelevant parameters are ignored.</font>
</p>
<p>
<font size="2">The depth parameter can be one of the constants GR_ZDEPTHVALUE_NEAREST, GR_ZDEPTHVALUE_FARTHEST, GR_WDEPTHVALUE_NEAREST, GR_WDEPTHVALUE_FARTHEST, or a direct representation of a value in the depth buffer. In the latter case the value is either a 1/<i>z </i>value 
(for GR_DEPTHBUFFER_ZBUFFER mode) or a 16-bit floating point format <i>w </i>value (for GR_DEPTHBUFFER_WBUFFER mode). The 16-bit floating point format is described in detail in the <i>Glide Programming Manual</i>.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">A buffer clear fills pixels at twice the rate of triangle rendering, therefore the performance cost of clearing the buffer is half the cost of rendering a rectangle. Clearing buffers is not always necessary and should be avoided if possible. When depth buf
fering is disabled and every visible pixel is rendered each frame, simply draw each frame on top of whatever was previously in the frame buffer. When depth buffering is enabled, a sorted background that covers the entire area can be drawn with the depth bu
ffer compare function set to GR_CMP_ALWAYS so that all pixel colors and depth values are replaced, and then normal depth buffering can be resumed.</font>
</p>
<p>
<font size="2">The constants GR_ZDEPTHVALUE_NEAREST and GR_ZDEPTHVALUE_FARTHEST assume that depth values decrease as they get further away from the eye. However, any linear function of 1/<i>z </i>can be used for computing depth buffer values and therefore they can either increa
se or decrease with distance from the eye.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grClipWindow, grColorMask, grDepthMask, grRenderBuffer</font>
</p>
<h2>
grBufferNumPending
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grBufferNumPending – return the number of queued buffer swap requests</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">int grBufferNumPending( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Voodoo Graphics has a large command queue located in off-screen memory. When time-consuming commands, such as large triangles or buffer swaps are executing, subsequent commands are placed in a command queue, including buffer swap requests. grBufferNumPendi
ng returns the number of queued buffer swap requests. An application typically wants to monitor this value and not get too far ahead of the rendering process.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The maximum value returned is 7, even though there may be more buffer swap requests in the queue. To minimize rendering latency in response to interactive input, grBufferNumPending should be called in a loop once per frame until the returned value is less 
than some small number such as 1, 2, or 3.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferSwap</font>
</p>
<h2>
grBufferSwap
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grBufferSwap – exchange front and back buffers</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grBufferSwap( int swap_interval )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">swap_interval	The number of vertical retraces to wait before swapping the front and back buffers.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grBufferSwap exchanges the front and back buffers in the graphics subsystem after swap_interval vertical retraces. If the swap_interval is 0, then the buffer swap does not wait for vertical retrace. Otherwise, the buffers are swapped after swap_interval ve
rtical retraces. For example, if the monitor frequency is 60 Hz, a swap_interval of 3 results in a maximum frame rate of 20 Hz.</font>
</p>
<p>
<font size="2">The exchange takes place during the next vertical retrace of the monitor, rather than immediately after grBufferSwap is called. If the application is double buffering, the Voodoo Graphics subsystem will stop rendering and wait until the swap occurs before 
executing more commands. If the application is triple buffering and the third rendering buffer is available, rendering commands will take place immediately in the third buffer.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">A swap_interval of 0 may result in visual artifacts, such as ‘tearing’, since a buffer swap can occur during the middle of a screen refresh cycle. This setting is very useful in performance monitoring situations, as true rendering performance can be measur
ed without including the time buffer swaps spend waiting for vertical retrace.</font>
</p>
<p>
<font size="2">grBufferSwap waits until there are fewer than 7 pending buffer swap requests in the Voodoo Graphics command FIFO before returning.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferNumPending</font>
</p>
<h2>
grChromakeyMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grChromakeyMode – enable/disable hardware chroma-keying</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grChromakeyMode( GrChromakeyMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	specifies whether chroma-keying should be enabled or disabled. Valid values are GR_CHROMAKEY_ENABLE and GR_CHROMAKEY_DISABLE.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Enables and disables chroma-keying. When chroma-keying is enabled, color values are compared to a global chroma-key reference value (set by grChromakeyValue). If the pixel’s color is the same as the chroma-key reference value, the pixel is discarded. The c
hroma-key comparison takes place before the color combine function. By default, chroma-keying is disabled.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The chroma-key comparison compares the chroma-key reference value to the <i>other</i> color specified in the configuration of the color combine unit.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grColorCombine, grChromakeyValue</font>
</p>
<h2>
grChromakeyValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grChromakeyValue – set the global chroma-key reference value</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grChromakeyValue( GrColor_t value )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">value	The new chroma-key reference value.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Sets the global chroma-key reference value as a packed RGBA value. The color format should be in the same format as specified in the <i>cformat</i> parameter to grSstWinOpen.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The chroma-key comparison compares the chroma-key reference value to the <i>other</i> color specified in the configuration of the color combine unit.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grColorCombine, grChromakeyMode</font>
</p>
<h2>
grClipWindow
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grClipWindow – set the size and location of the hardware clipping window</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grClipWindow(FxU32 minx, FxU32 miny, FxU32 maxx, FxU32 maxy )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">minx	The lower x screen coordinate of the clipping window.</font>
</p>
<p>
<font size="2">miny	The lower y screen coordinate of the clipping window.</font>
</p>
<p>
<font size="2">maxx	The upper x screen coordinate of the clipping window.</font>
</p>
<p>
<font size="2"> maxy	The upper y screen coordinate of the clipping window.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grClipWindow specifies the hardware clipping window. Any pixels outside the clipping window are rejected. Values are inclusive for minimum x and y values and exclusive for maximum x and y values. The clipping window also specifies the area grBufferClear cl
ears.</font>
</p>
<p>
<font size="2">At startup the default values for the clip window are the full size of the screen, e.g. (0,0,640,480) for 640×480 mode and (0,0,800,600) for 800×600 mode. To disable clipping simply set the size of the clip window to the screen size. The clipping window sh
ould not be used for general purpose primitive clipping; since clipped pixels are processed but discarded, proper geometric clipping should be done by the application for best performance. The clipping window should be used to prevent stray pixels that app
ear from imprecise geometric clipping. Note that if the pixel pipeline is disabled (see grLfbLock), clipping is not performed on linear frame buffer writes.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferClear, grLfbLock</font>
</p>
<h2>
grColorCombine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grColorCombine – configure the color combine unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grColorCombine(	GrCombineFunction_t func, </font>
</p>
<p>
<font size="2">	GrCombineFactor_t factor,</font>
</p>
<p>
<font size="2">	GrCombineLocal_t local, </font>
</p>
<p>
<font size="2">	GrCombineOther_t other, </font>
</p>
<p>
<font size="2">	FxBool invert </font>
</p>
<p>
<font size="2">	)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">func	Specifies the function used in source color generation. Valid parameters are described below:</font>
</p>
<table width="479" border="1" frame="BOX" rules="ALL">
<colgroup><col width="346"><col width="133"></colgroup><tbody><tr>
<td width="346" valign="TOP">
<p>
<font size="2"><b>Combine Function</b></font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><b>computed color</b></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_ZERO</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL_ALPHA</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_OTHER</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º <i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + (1 – <i>f</i>) * <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_LOCAL</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º (1 – <i>f</i>) * <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="133" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
</tbody></table>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">factor	Specifies the scaling factor <i>f </i>used in source color generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="342" border="1" frame="BOX" rules="ALL">
<colgroup><col width="248"><col width="94"></colgroup><tbody><tr>
<td width="248" valign="TOP">
<p>
<font size="2"><b>Combine Factor</b></font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><b>Scale Factor (<i>f</i>)</b></font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_NONE</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">Unspecified</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ZERO</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_OTHER_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_TEXTURE_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>texture</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_OTHER_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_TEXTURE_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>texture</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">local	Specifies the local color used in source color generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="342" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="188"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2"><b>Local Combine Source</b></font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2"><b>Local Color (<i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</b></font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_NONE</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Unspecified color</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_ITERATED</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Iterated vertex color (Gouraud shading)</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_LOCAL_CONSTANT</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Constant color</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">other	Specifies the other color used in source color generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="342" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="188"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2"><b>Other Combine Source</b></font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2"><b>Other Color (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>)</b></font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_NONE</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Unspecified color</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_ITERATED</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Iterated vertex color (Gouraud shading)</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_TEXTURE</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Color from texture map</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_COMBINE_OTHER_CONSTANT</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Constant color</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">invert	Specifies whether the generated source color should be bitwise inverted as a final step.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grColorCombine configures the color combine unit of the Voodoo Graphics subsystem’s hardware pipeline. This provides a low level mechanism for controlling all modes of the color combine unit without manipulating individual register bits. </font>
</p>
<p>
<font size="2">The color combine unit computes the function specified by the combine function on the inputs specified by the local combine source, other combine source, and the combine scale factor. The result is clamped to [0..255], and then a bitwise inversion may be a
pplied, controlled by the <i>invert</i> parameter. The resulting color goes to the alpha and depth units.</font>
</p>
<p>
<font size="2">The default color combine mode is grColorCombine(<b><font size="1">GR_COMBINE_FUNCTION_SCALE_OTHER</font></b>, <b><font size="1">GR_COMBINE_FACTOR_ONE</font></b>, <b><font size="1">GR_COMBINE_LOCAL_ITERATED</font></b>, <b><font size="1">GR_COMBINE_OTHER_ITERATED</font></b>).</font>
</p>
<p>
<font size="2">GR_COMBINE_LOCAL_CONSTANT and GR_COMBINE_OTHER_CONSTANT select the constant color specified in a previous call to <b><font size="1">grConstantColorValue</font></b>. The iterated color selected by GR_COMBINE_LOCAL_ITERATED or GR_COMBINE_OTHER_ITERATED are the red, green, blue, and alph
a values associated with a drawing primitive’s vertices.</font>
</p>
<p>
<font size="2">grColorCombine also keeps track of required vertex parameters for the rendering routines. GR_COMBINE_FACTOR_NONE, GR_COMBINE_LOCAL_NONE and GR_COMBINE_OTHER_NONE are provided to indicate that no parameters are required. Currently they are the same as GR_CO
MBINE_FACTOR_ZERO, GR_COMBINE_LOCAL_CONSTANT, and GR_COMBINE_OTHER_CONSTANT respectively.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">In the tables above, <i>A<font size="1"><sub>local </sub></font></i><font size="1"><sub></sub></font>is the local alpha value selected by grAlphaCombine and <i>A<sub>other<font size="1"> </font></sub></i><sub><font size="1"></font></sub><font size="1"></font>is the other alpha value selected by grAlphaCombine.</font>
</p>
<p>
<font size="2">Inverting the bits in a color is the same as computing (1.0 – color) for floating point color values in the range [0..1] or (255 – color) for 8-bit color values in the range [0..255].</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine, grConstantColorValue, grDrawTriangle</font>
</p>
<h2>
grColorMask
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grColorMask – enable/disable writing into the color and alpha buffers</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grColorMask( FxBool rgb, FxBool alpha )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">rgb<i>	The new color buffer mask.</i><i></i></font>
</p>
<p>
<font size="2">alpha	The new alpha buffer mask.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grColorMask specifies whether the color and/or alpha buffers can or cannot be written to during rendering operations. If rgb is FXFALSE, for example, no change is made to the color buffer regardless of the drawing operation attempted. The alpha parameter i
s ignored if depth buffering is enabled since the alpha and depth buffers share memory.</font>
</p>
<p>
<font size="2">The value of grColorMask is ignored during linear frame buffer writes if the pixel pipeline is disabled (see grLfbLock). The default values are all FXTRUE, indicating that the associated buffers are writable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferClear, grDepthMask, grLfbLock</font>
</p>
<h2>
grConstantColorValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grConstantColorValue – set the global constant color</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grConstantColorValue( GrColor_t color )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">color	The new constant color.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Glide refers to a global constant color in the color combine unit and alpha combine unit if GR_COMBINE_LOCAL_CONSTANT or GR_COMBINE_OTHER_CONSTANT are specified. This constant color is set with grConstantColorValue. The color format should be in the same f
ormat as specified in the <i>cformat</i> parameter to grSstWinOpen. The default value is 0xFFFFFFFF.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine, grColorCombine</font>
</p>
<h2>
grCullMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grCullMode – set the cull mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grCullMode( GrCullMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new culling mode. Valid parameters are GR_CULL_DISABLE, GR_CULL_NEGATIVE, and GR_CULL_POSITIVE.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Specifies the type of backface culling, if any, that Glide performs when rendering a triangle. Glide computes the signed area of a triangle prior to rendering, and the sign of this area can be used for backface culling operations. If the sign of the area m
atches the mode, then the triangle is rejected. grCullMode assumes that GR_CULL_POSITIVE corresponds to a counter-clockwise oriented triangle when the origin is GR_ORIGIN_LOWER_LEFT and a clockwise oriented triangle when the origin is GR_ORIGIN_TOP_LEFT.</font>
</p>
<center><table align="CENTER" width="403" border="1" frame="BOX" rules="ALL">
<colgroup><col width="134"><col width="153"><col width="116"></colgroup><tbody><tr>
<td width="134" valign="TOP">
<p>
<b>Origin Location</b>
</p></td>
<td width="153" valign="TOP">
<p>
<b>Triangle Orientation</b>
</p></td>
<td width="116" valign="TOP">
<p>
<b>Signed Area</b>
</p></td>
</tr>
<tr>
<td width="134" valign="TOP">
<p>
GR_ORIGIN_LOWERLEFT
</p></td>
<td width="153" valign="TOP">
<p>
clockwise
</p></td>
<td width="116" valign="TOP">
<p>
negative
</p></td>
</tr>
<tr>
<td width="134" valign="TOP">
<p>
GR_ORIGIN_LOWERLEFT
</p></td>
<td width="153" valign="TOP">
<p>
counter-clockwise
</p></td>
<td width="116" valign="TOP">
<p>
positive
</p></td>
</tr>
<tr>
<td width="134" valign="TOP">
<p>
GR_ORIGIN_UPPERLEFT
</p></td>
<td width="153" valign="TOP">
<p>
clockwise
</p></td>
<td width="116" valign="TOP">
<p>
positive
</p></td>
</tr>
<tr>
<td width="134" valign="TOP">
<p>
GR_ORIGIN_UPPERLEFT
</p></td>
<td width="153" valign="TOP">
<p>
counter-clockwise
</p></td>
<td width="116" valign="TOP">
<p>
negative
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grCullMode has no effect on points and lines, but does effect all triangle rendering primitives including polygons.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawTriangle</font>
</p>
<h2>
grDepthBiasLevel
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDepthBiasLevel – set the depth bias level</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDepthBiasLevel( FxI16 level )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">level	The new depth bias level.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDepthBiasLevel allows an application to specify a depth bias used when rendering coplanar polygons. Specifically, if two polygons are coplanar but do not share vertices, e.g. a surface detail polygon sits on top of a larger polygon, artifacts such as “po
ke through” may result. To remedy such artifacts an application should increment or decrement the depth bias level, as appropriate for the depth buffer mode and function, per coplanar polygon. For left handed coordinate systems where 0x0000 corresponds to 
“nearest to viewer” and 0xFFFF corresponds “farthest from viewer” depth bias levels should be decremented on successive rendering of coplanar polygons.</font>
</p>
<p>
<font size="2">Depth biasing is mutually exclusive of linear frame buffer writes.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">In depth buffering modes GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS and GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS, the depth bias level specifies the value to compare depth buffer values against, and is not added to the source depth value when writing to the dept
h buffer. See grDepthBufferMode for more information.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferMode, grDepthMask</font>
</p>
<h2>
grDepthBufferFunction
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDepthBufferFunction – specify the depth buffer comparison function</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDepthBufferFunction( GrCmpFnc_t func )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">func	The new depth comparison function.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDepthBufferFunction specifies the function used to compare each rendered pixel’s depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled with grDepthBufferMode. The choice of depth buffer
 function is typically dependent upon the depth buffer mode currently active.</font>
</p>
<p>
<font size="2">The valid comparison functions are as follows:</font>
</p>
<center><table align="CENTER" width="469" border="1" frame="BOX" rules="ALL">
<colgroup><col width="102"><col width="367"></colgroup><tbody><tr>
<td width="102" valign="TOP">
<p>
<font size="2"><i><b>func</b></i></font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2"><b>Comparison Function</b></font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_NEVER</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Never passes.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_LESS</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is less than the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_EQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is equal to the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_LEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is less than or equal to the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_GREATER</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is greater than the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_NOTEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is not equal to the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_GEQUAL</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Passes if the pixel’s depth value is greater than or equal to the stored depth value.</font>
</p></td>
</tr>
<tr>
<td width="102" valign="TOP">
<p>
<font size="2">GR_CMP_ALWAYS</font>
</p></td>
<td width="367" valign="TOP">
<p>
<font size="2">Always passes</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The default comparison function is GR_CMP_LESS.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferMode, grDepthMask, grDepthBiasLevel, grLfbConstantDepth</font>
</p>
<h2>
grDepthBufferMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDepthBufferMode – set the depth buffering mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDepthBufferMode( GrDepthBufferMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new depth buffering mode.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDepthBufferMode specifies the type of depth buffering to be performed. Valid modes are GR_DEPTHBUFFER_DISABLE, GR_DEPTHBUFFER_ZBUFFER, GR_DEPTHBUFFER_WBUFFER, GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS, or GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS. If GR_DEPTHB
UFFER_ZBUFFER or GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS is selected, then the Voodoo Graphics subsystem will perform 16-bit fixed point <i>z</i> buffering. If GR_DEPTHBUFFER_WBUFFER or GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS is selected, then the Voodoo Graphics s
ubsystem will perform 16-bit floating point <i>w</i> buffering. By default the depth buffer node is GR_DEPTHBUFFER_DISABLE. Refer to the <i>Glide Programming Guide </i>for more information about <i>w </i>and <i>z</i> buffering.</font>
</p>
<p>
<font size="2">If GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS or GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS is selected, then the bias specified with grDepthBiasLevel is used as a pixel’s depth value for comparison purposes only. Depth buffer values are compared against the depth
 bias level and if the compare passes and the depth buffer mask is enabled, the pixel’s unbiased depth value is written to the depth buffer. This mode is useful for clearing beneath cockpits and other types of overlays without effecting either the color or
 depth values for the cockpit or overlay.</font>
</p>
<p>
<font size="2">Consider the following example: the depth buffer is cleared to 0xFFFF and a cockpit is drawn with a depth value of zero. Next, the scene beneath the cockpit is drawn with depth buffer compare function of GR_CMP_LESS rendering pixels only where the cockpit 
is not drawn. To clear the color and depth buffers underneath the cockpit without disturbing the cockpit, the area to be cleared is rendered using triangles (not grBufferClear) with the depth bias level set to zero, a depth buffer compare function of GR_CM
P_NOTEQUAL and a depth buffer mode of GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS or GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS. All pixels whose previous depth buffer values are not equal to zero will be rendered and the depth buffer will be set to either unbiased
 <i>z </i>or <i>w </i>depending on the mode. Using this method, the color and depth buffers can be cleared to any desired value beneath a cockpit or overlay without effecting the cockpit or overlay. Or more desirably, sorted background polygons from the scene to be rend
ered that cover all of the visible area can be rendered in this mode, saving the time consuming clearing operation. After the depth buffer is cleared beneath the cockpit, the depth buffer mode is returned to either GR_DEPTHBUFFER_ZBUFFER or GR_DEPTHBUFFER_
WBUFFER and the compare function is returned to its normal setting (GR_CMP_LESS in this example). Note that since this mode of clearing is performed using triangle rendering, the fill rate is one half that of a rectangle clear using grBufferClear. In the c
ase where sorted background polygons are used to clear underneath the cockpit, this method should always be faster than the alternative of calling grBufferClear and then drawing the background polygons. In the case where background polygons are not used, b
oth methods:</font>
</p>
<ol><li>
clearing the buffers with grBufferClear and then repainting the cockpit
</li><li>
clearing beneath the cockpit with triangles and not repainting the cockpit</li></ol>
<p>
<font size="2">should be compared and the faster method chosen. Avoiding a cockpit repaint is important: cockpits are typically rendered with linear frame buffer writes and while the writes are individually fast, the process can be lengthy if the cockpit covers many pixe
ls.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Since alpha, depth, and triple buffering are mutually exclusive of each other, enabling depth buffering when using either the alpha or triple buffer will have undefined results.</font>
</p>
<p>
<font size="2">GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS and GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS modes are not available in revision 1 of the Pixel<i>fx</i> chip (use grSstQueryHardware to obtain the revision number).</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release that supported GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS and GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferFunction, grDepthMask, grDepthBiasLevel, grLfbConstantDepth</font>
</p>
<h2>
grDepthMask
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDepthMask – enable/disable writing into the depth buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDepthMask( FxBool enable )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">enable	The new depth buffer mask.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDepthMask specifies whether the depth buffer is enabled for writing. If enable is FXFALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is disabled.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Since the alpha, depth, and triple buffers share the same memory grDepthMask should be called only if depth buffering is being used.</font>
</p>
<p>
<font size="2">grDepthMask is ignored during linear frame buffer writes if the pixel pipeline is bypassed (see grLfbLock).</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferClear, grDepthBufferFunction, grDepthBufferMode, grDepthBiasLevel, grLfbConstantDepth, grLfbLock</font>
</p>
<h2>
grDisableAllEffects
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDisableAllEffects – disable all special effects in the Voodoo Graphics subsystem</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDisableAllEffects( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDisableAllEffects disables all special effects (alpha blending, alpha testing, chroma-keying, fog, depth buffering) in the Voodoo Graphics subsystem with the exception of clipping, dithering, and the color/depth masks. Effects must be re-enabled individu
ally.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaBlendFunction, grAlphaTestFunction, grChromakeyMode, grDepthBufferMode, grFogMode</font>
</p>
<h2>
grDitherMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDitherMode – sets the dithering mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDitherMode( GrDitherMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new dithering mode.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDitherMode selects the form of dithering used when converting 24-bit RGB values to the 16-bit RGB color buffer format. Valid values are GR_DITHER_DISABLE, GR_DITHER_2x2, and GR_DITHER_4x4. GR_DITHER_DISABLE forces a simple truncation, which may result in
 noticeable banding. GR_DITHER_2x2 uses a 2x2 ordered dither matrix, and GR_DITHER_4x4 uses a 4x4 ordered dither matrix.</font>
</p>
<p>
<font size="2">The default dithering mode is GR_DITHER_4x4. grDitherMode is <i>not</i> affected by grDisableAllEffects.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<h2>
grDrawLine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawLine – draw a one-pixel-wide arbitrarily oriented line</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawLine( const GrVertex *a, const GrVertex *b )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">a, b	Endpoints and attributes of the line.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Renders a one-pixel-wide arbitrarily oriented line with the given endpoints. All current Glide attributes will affect the appearance of the line.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawPoint, grDrawTriangle</font>
</p>
<h2>
grDrawPlanarPolygon
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawPlanarPolygon – draw a convex planar polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawPlanarPolygon( int nVerts, int ilist[], const GrVertex vlist[] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">ilist	Array of indices into <i>vlist</i>.</font>
</p>
<p>
<font size="2">vlist	Array of vertices indexed by <i>ilist</i>.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDrawPlanarPolygon renders a convex polygon of an arbitrary number of vertices. The polygon’s coordinates and parameters are assumed to be planar, so parameter gradients will be computed only a single time for the entire polygon. It is assumed that the po
lygon does not need any form of clipping.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The convex polygon is triangulated from the first vertex, <i>vlist</i>[<i>ilist</i>[0]].</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawPlanarPolygonVertexList, grDrawPolygon, grDrawTriangle</font>
</p>
<h2>
grDrawPlanarPolygonVertexList
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawPlanarPolygonVertexList – draw a convex planar polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawPlanarPolygonVertexList( int nVerts, const GrVertex vlist[] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">vlist	Array of vertices in the polygon.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDrawPlanarPolygonVertexList renders a convex polygon of an arbitrary number of vertices. The polygon’s coordinates and parameters are assumed to be planar, so parameter gradients will be computed only a single time for the entire polygon. It is assumed t
hat the polygon does not need any form of clipping.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The convex polygon is triangulated from the first vertex, <i>vlist</i>[0].</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release that supported grDrawPlanarPolygonVertexList.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawPlanarPolygon, grDrawPolygon, grDrawTriangle</font>
</p>
<h2>
grDrawPoint
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawPoint – draw a point</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawPoint( const GrVertex *a )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">a	Location and attributes of the point.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Renders a single point. All current Glide attributes will affect the appearance of the point. If many points need to be rendered to the screen, e.g. a sprite, use linear frame buffer writes instead.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawLine, grDrawTriangle, grLfbLock</font>
</p>
<h2>
grDrawPolygon
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawPolygon – draw a convex non-planar polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawPolygon( int nVerts, int ilist[], const GrVertex vlist[] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">ilist	Array of indices into <i>vlist</i>.</font>
</p>
<p>
<font size="2">vlist	Array of vertices indexed by <i>ilist</i>.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDrawPolygon renders a convex polygon with an arbitrary number of vertices. The polygon’s coordinates are assumed to be planar and to lie within the clipping window. Parameters need not be planar, and parameter gradients will be computed multiple times ac
ross the face of the polygon. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The convex polygon is triangulated from the first vertex, <i>vlist</i>[<i>ilist</i>[0]].</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawPlanarPolygon, grDrawPolygonVertexList, grDrawTriangle</font>
</p>
<h2>
grDrawPolygonVertexList
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawPolygonVertexList – draw a convex non-planar polygon</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawPolygonVertexList( int nVerts, const GrVertex vlist[] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">nVerts	Number of vertices in the polygon.</font>
</p>
<p>
<font size="2">vlist	Array of vertices in the polygon.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grDrawPolygonVertexList renders a convex polygon of an arbitrary number of vertices. The polygon’s coordinates are assumed to be planar and to lie within the clipping window. Parameters need not be planar, and parameter gradients will be computed multiple 
times across the face of the polygon. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The convex polygon is triangulated from the first vertex, <i>vlist</i>[0].</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawPlanarPolygon, grDrawPlanarPolygonVertexList, grDrawPolygon, grDrawTriangle</font>
</p>
<h2>
grDrawTriangle
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grDrawTriangle – draw a triangle</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grDrawTriangle( const GrVertex *a, const GrVertex *b, const GrVertex *c )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">a, b, c	Location and attributes of the vertices defining the triangle.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Renders an arbitrarily oriented triangle. All current Glide attributes will affect the appearance of the triangle. Triangles are rendered with the following filling rules:</font>
</p>
<ol><li>
Zero area triangles render zero pixels.
</li><li>
Pixels are rendered if and only if their center lies within the triangle.</li></ol>
<p>
<font size="2">A pixel center is within a triangle if it is inside all three of the edges. If a pixel center lies exactly on an edge, it is considered to be inside for the left and horizontal bottom (lower<i> y </i>coordinate) edges and outside for the right and horizontal top 
(higher<i> y </i>coordinate) edges. If a pixel is outside any edge, it is considered to be outside the triangle.</font>
</p>
<p>
<font size="2">In the following picture, a pixel whose center is at the intersection of the 8 triangles is rendered only by triangle D. The center pixel lies on a right edge in triangles A, B, E, F, G, and H. In triangle C and H, the pixel lies exactly on a top edge (hig
h Y). But triangle D, the pixel lies exactly on the bottom and left edges and is therefore considered to be inside the triangle.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">These filling rules guarantee that perfect meshes will draw every pixel within the mesh once and only once.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawLine, grDrawPoint, grDrawPolygon</font>
</p>
<h2>
grErrorSetCallback
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grErrorSetCallback – install a user-defined error-handler</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grErrorSetCallback( void (*function)(const char *string, FxBool fatal) )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">function	Pointer to a function to be called with all future errors.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grErrorSetCallback allows an application to install a callback function to handle error messages generated internally by Glide. The callback function accepts a string describing the error and a flag indicating if the error is fatal or recoverable. grErrorS
etCallback is relevant only for the debug build of Glide; the release build of Glide removes all internal parameter validation and error checking, thus the user installed callback will never be called.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<h2>
grFogColorValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grFogColorValue – set the global fog color</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grFogColorValue( GrColor_t value )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">value	The new global fog color.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grFogColorValue specifies the global fog color to be used during fog blending operations. The color format should be in the same format as specified in the <i>cformat</i> parameter to grSstWinOpen.</font>
</p>
<p>
<font size="2">The fog operation blends the fog color (C<i><sub>fog</sub></i>) with each rasterized pixel’s color (C<i><sub>in</sub></i>) using a blending factor <b>f</b>. Factor <b>f</b> is derived either from iterated alpha or a user downloaded fog table based on the pixel’s w component, depending on the current grFog
Mode.</font>
</p>
<p>
<font size="2">The new color is computed as follows:</font>
</p>
<p align="CENTER">
<font size="2"><font size="4">C<i><sub>out</sub></i> = <b><i>f</i></b> C<i><sub>fog</sub></i> + (1–<b><i>f</i></b>)C<i><sub>in</sub></i></font><i><sub></sub></i></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Fog is applied after color combining and before alpha blending.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDisableAllEffects, grFogMode, grFogTable</font>
</p>
<h2>
grFogMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grFogMode – enable/disable per-pixel fog blending operations</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grFogMode( GrFogMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new fog mode.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grFogMode enables/disables fog blending operations. Valid parameters are GR_FOG_DISABLE, GR_FOG_WITH_ITERATED_ALPHA, and GR_FOG_WITH_TABLE. The fog operation blends the fog color (C<i><sub>fog</sub></i>) with each rasterized pixel’s color (C<i><sub>in</sub></i>) using a blending factor <b>f</b>. A 
value of <b><i>f </i></b>= 0 indicates minimum fog density and a value of <b><i>f </i></b>= 255 indicates maximum fog density.</font>
</p>
<p>
<font size="2">The new color is computed as follows:</font>
</p>
<p align="CENTER">
<font size="2"><font size="4">C<i><sub>out</sub></i> = <b><i>f</i></b> C<i><sub>fog</sub></i> + (1–<b><i>f</i></b>)C<i><sub>in</sub></i></font><i><sub></sub></i></font>
</p>
<p>
<font size="2">Factor <b>f</b><b> </b>is determined by mode. If <i>mode</i> is GR_FOG_WITH_ITERATED_ALPHA, then <b><i>f</i> </b>is equal to the integer bits of iterated alpha. If <i>mode</i> is GR_FOG_WITH_TABLE, then <b><i>f</i> </b>is computed by interpolating between fog table entries, where the fog table is indexed with a
 floating point representation of the pixel’s <i>w</i> component.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Fog is applied after color combining and before alpha blending.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogColorValue, grFogTable</font>
</p>
<h2>
grFogTable
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grFogTable – download a fog table</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grFogTable( const GrFog_t table[GR_FOG_TABLE_SIZE] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">table	The new fog table.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grFogTable downloads a new table of 8-bit values that are logically viewed as fog opacity values corresponding to various depths. The table entries control the amount of blending between the fog color and the pixel’s color. A value of 0x00 indicates no fog
 blending and a value of 0xFF indicates complete fog.</font>
</p>
<p>
<font size="2">The fog operation blends the fog color (C<i><sub>fog</sub></i>) with each rasterized pixel’s color (C<i><sub>in</sub></i>) using a blending factor <b>f</b>. Factor <b>f</b> depends upon the most recent call to grFogMode. If the grFogMode is set to GR_FOG_WITH_TABLE, the factor <b>f</b> is computed by interpolati
ng between fog table entries, where the fog table is indexed with a floating point representation of the pixel’s <i>w</i> component. The order of the entries within the fog table correspond roughly to their distance from the viewer. The exact world <i>w</i> correspondin
g to fog table entry <i>i</i> can be found by calling guFogTableIndexToW(i) or by computing:</font>
</p>
<p align="CENTER">
<font size="1">pow(2.0,3.0+(double)(i&gt;&gt;2)) / (8-(i&amp;3));</font>
</p>
<p>
<font size="1"><br></font>
</p>
<p>
<font size="2">The new color is computed as follows:</font>
</p>
<p align="CENTER">
<font size="2"><font size="4">C<i><sub>out</sub></i> = <b><i>f</i></b> C<i><sub>fog</sub></i> + (1–<b><i>f</i></b>)C<i><sub>in</sub></i></font><i><sub></sub></i></font>
</p>
<p>
<font size="2">An exponential fog table can be generated by computing (1-<i>e</i><sup>-<i>kw</i></sup><i></i>)*255 where <i>k</i> is the fog density and <i>w</i> is world distance. It is usually best to normalize the fog table so that the last entry is 255.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The difference between consecutive entries in the fog table must be less than 64.</font>
</p>
<p>
<font size="2">Fog is applied after color combining and before alpha blending.</font>
</p>
<p>
<font size="2">There are several Glide Utility APIs for generating fog tables.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogMode, grFogColorValue, guFogTableIndexToW</font>
</p>
<h2>
grGammaCorrectionValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGammaCorrectionValue – set the gamma correction value</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGammaCorrectionValue( float value )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">value	The new gamma value.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGammaCorrectionValue sets the gamma correction value used during video refresh. Gamma is a positive floating point value from 0.0 to 20.0. Typical values are in the range [1.3..2.2]. The default value is 1.0 (i.e. a linear ramp is used).</font>
</p>
<p>
<font size="2">The displayed RGB value (<i>RGB<sub>gamma</sub></i><sub></sub>) is computed from the RGB value read from the frame buffer (<i>RGB<sub>fb</sub></i><sub></sub>) according to the following equation:</font>
</p>
<p align="CENTER">
<font size="2"><font size="4"><i>RGB<sub>gamma</sub></i><sub></sub> = [(<i>RGB<sub>fb</sub></i><sub></sub>/255)<sup>1/<i>gamma</i></sup><i></i>]*255</font></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">For more information on gamma correction, refer to [FOLE90].</font>
</p>
<h2>
grGlideGetVersion
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGlideGetVersion – return the version of Glide</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGlideGetVersion( char version[80] )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">version	Character array to receive the text string describing the Glide version.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGlideGetVersion fills version with a null-terminated text string that describes the Glide version.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">A sample version string is “Glide Version 2.2”.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grGlideGetVersion.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideInit</font>
</p>
<h2>
grGlideGetState
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGlideGetState – get the current state of the current Voodoo Graphics subsystem</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGlideGetState( GrState *state )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">state	Pointer to a GrState structure where the state is to be stored.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGlideGetState makes a copy of the current state of the current Voodoo Graphics subsystem. This allows an application to save the state and then restore it later using grGlideSetState.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideSetState</font>
</p>
<h2>
grGlideInit
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGlideInit – initialize the Glide library</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGlideInit( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGlideInit initializes the Glide library, performing tasks such as finding any installed Voodoo Graphics subsystems, allocating memory, and initializing state variables. grGlideInit must be called before any other Glide routines are called.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grSstQueryBoards can be called before grGlideInit.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideGetVersion, grGlideShutdown, grSstWinOpen, grSstQueryBoards, grSstQueryHardware, grSstSelect</font>
</p>
<h2>
grGlideSetState
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGlideSetState – set the state of the currently active Voodoo Graphics subsystem</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGlideSetState( const GrState *state )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">state	Pointer to a GrState structure containing the new state.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGlideSetState sets the state of the currently active Voodoo Graphics subsystem. This API is typically paired with calls to grGlideGetState so that an application can save and restore the state.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideGetState</font>
</p>
<h2>
grGlideShutdown
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grGlideShutdown – shut down the Glide library</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grGlideShutdown( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grGlideShutdown frees up any system resources allocated by Glide, including memory, and interrupt vectors. grGlideShutdown should be called immediately before program termination.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideInit</font>
</p>
<h2>
grHints
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grHints – informs Glide of special conditions regarding optimizations</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grHints( GrHints_t type, FxU32 hintMask )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">type	Specifies the type of hint.</font>
</p>
<p>
<font size="2">hintMask	A bitmask of ORed hints.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grHints informs Glide of special conditions regarding optimizations and operation. Each type of hint controls a different optimization or mode of operation. Hints of a given type are ORed together into a hintMask. The default hintMask is 0x00.</font>
</p>
<p>
<font size="2"> The GR_HINT_STWHINT hint type controls <i>stw</i> parameter optimization. By default, Glide assumes that all <i>w</i> coordinates (oow) in the GrVertex structure are identical, and that all <i>s</i> and <i>t</i> coordinates (sow and tow) are also identical. This greatly reduces the 
amount of work Glide has to perform when computing gradients for <i>s</i>, <i>t</i>, and <i>w</i>, and transferring data to the graphics hardware. The <i>stw</i> hints alert Glide that specific values in the GrVertex structure are different and that gradients need to be computed for 
these values. </font>
</p>
<p>
<font size="2">The <i>stw</i> hints also specify Glide’s source for the parameter values. There is an implicit ordering of TMUs within Glide, starting with TMU0, followed by TMU1, and TMU2. By default, Glide reads <i>s </i>and <i>t</i> coordinates from the GrVertex structure for the first TM
U that is active. Whenever <i>s </i>and <i>t</i> coordinates are read they are transmitted to all subsequent TMUs. For example, if texturing is active in TMU1 but not active in TMU0, then <i>s </i>and <i>t</i> coordinates are read from GrVertex.tmuvtx[1] and broadcast to TMU1 and TMU
2. Once <i>s </i>and <i>t</i> coordinates are read, they will not be read again unless a hint is specified. If one of the subsequent units has a unique or different parameter value, then a hint must be used. If a hint is specified, the parameter value will be read again
 and sent to the specified unit and all other units following it.</font>
</p>
<p>
<font size="2">The <i>w</i> hints inform Glide where to look for <i>w</i> coordinates. The rule for the <i>w</i> coordinate is very simple: the <i>w</i> coordinate is read from GrVertex.oow and broadcast to all TMUs unless a <i>w</i> hint is specified. If a <i>w</i> hint is specified, then if <i>w</i> buffering or tabl
e-based fog is enabled, GrVertex.oow is read and sent to all TMUs first. Then <i>w</i> is read from the GrVertex.tmuvtx[] structure corresponding to the hint and broadcast to all subsequent TMUs. </font>
</p>
<p>
<font size="2"> The tables below describe the values:</font>
</p>
<center><table align="CENTER" width="441" border="1" frame="BOX" rules="ALL">
<colgroup><col width="159"><col width="281"></colgroup><tbody><tr>
<td width="159" valign="TOP">
<p>
<font size="2"><b>Hint</b></font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><b>Description</b></font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_ST_DIFF_TMU0</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>s</i> and <i>t</i> for TMU0 are different than previous values.</font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_ST_DIFF_TMU1</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>s</i> and <i>t</i> for TMU1 are different than previous values.</font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_ST_DIFF_TMU2</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>s</i> and <i>t</i> for TMU2 are different than previous values.</font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_W_DIFF_TMU0</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>w</i> for TMU0 is different than previous <i>w</i> values.</font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_W_DIFF_TMU1</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>w</i> for TMU1 is different than previous <i>w</i> values.</font>
</p></td>
</tr>
<tr>
<td width="159" valign="TOP">
<p>
<font size="2">GR_STWHINT_W_DIFF_TMU2</font>
</p></td>
<td width="281" valign="TOP">
<p>
<font size="2"><i>w</i> for TMU2 is different than previous <i>w</i> values.</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The GR_HINT_ALLOW_MIPMAP_DITHER hint type controls whether or not GR_MIPMAP_NEAREST_DITHER mode can be used. If hintMask is zero, then GR_MIPMAP_NEAREST_DITHER mode cannot be enabled with grTexMipMapMode(). This is the default. To allow GR_MIPMAP_NEAREST_D
ITHER mode to be used, specify a non-zero hintMask with the hint.</font>
</p>
<p>
<font size="2">Dithered mipmapping is disabled by default because it can cause a performance loss of 20% to 30% in some cases. And since the presence or absence of mipmap dithering is not very noticeable, it is very hard to determine the cause of the performance loss. Th
erefore, Glide disallows this mode by default, but it can be used by calling grHints. </font>
</p>
<p>
<font size="2">If dithered mipmapping is used, measure performance with and without it. If there is a significant performance difference, don’t use it. The trade-off is that there may be visible mipmap bands, which can be eliminated by using trilinear mipmapping. On mult
iple TMU boards this is a one-pass operation, otherwise it requires two passes. Alternatively, dithered mipmapping can be allowed but disabled for most polygons and enabled only for those polygons that require it.</font>
</p>
<p>
<font size="2">If there is no performance difference with and without dithered mipmapping, but the image quality did not improve with dithered mipmapping, don’t use it. As you enhance or extend your program, you run the risk of creating a situation in which performance l
oss due to dithered mipmapping could occur. It is best to selectively enabled dithered mipmapping just for the polygons that require it.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Since TMU0 is the first functional unit with <i>s</i> and <i>t</i> coordinates, the GR_STWHINT_ST_DIFF_TMU0 hint need never be given.</font>
</p>
<p>
<font size="2">grSstWinOpen initializes various Glide state variables, including hints. Thus, grHint should be called after grSstWinOpen if you want something other than the default hint settings. </font>
</p>
<p>
<font size="2">see Also</font>
</p>
<p>
<font size="2">grDrawLine, grDrawPoint, grDrawTriangle</font>
</p>
<p>
<font size="2"><br></font>
</p>
<h2>
grLfbConstantAlpha
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbConstantAlpha – set the constant alpha value for linear frame buffer writes</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbConstantAlpha( GrAlpha_t alpha )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">alpha	The new constant alpha value.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Some linear frame buffer write modes, specifically GR_LFBWRITEMODE_555, GR_LFBWRITEMODE_888, GR_LFBWRITEMODE_555_DEPTH, and GR_LFBWRITEMODE_DEPTH_DEPTH, do not contain alpha information. grLfbConstantAlpha specifies the alpha value for these linear frame b
uffer write modes. This alpha value is used if alpha testing and blending operations are performed during linear frame buffer writes. The default constant alpha value is 0xFF.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">If a linear frame buffer format contains alpha information, then the alpha supplied with the linear frame buffer write is used, and the constant alpha value set with grLfbConstantAlpha is ignored.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaTestFunction, grAlphaBlendFunction</font>
</p>
<h2>
grLfbConstantDepth
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbConstantDepth – set the constant depth value for linear frame buffer writes</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbConstantDepth( FxU16 depth )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">depth	The new constant depth value.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Some linear frame buffer write modes, specifically GR_LFBWRITEMODE_555, GR_LFBWRITEMODE_565, GR_LFBWRITEMODE_1555, GR_LFBWRITEMODE_888, GR_LFBWRITEMODE_8888, and GR_LFBWRITEMODE_ALPHA_ALPHA, do not possess depth information. grLfbConstantDepth specifies th
e depth value for these linear frame buffer write modes. This depth value is used for depth buffering and fog operations and is assumed to be in a format suitable for the current depth buffering mode. The default constant depth value is 0x00.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">If a linear frame buffer format contains depth information, then the depth supplied with the linear frame buffer write is used, and the constant depth value set with grLfbConstantDepth is ignored.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferMode, grFogMode</font>
</p>
<h2>
grLfbLock
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbLock – lock a frame buffer in preparation for direct linear frame buffer accesses.</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grLfbLock(	GrLock_t type, </font>
</p>
<p>
<font size="2">	GrBuffer_t buffer, </font>
</p>
<p>
<font size="2">	GrLfbWriteMode_t writeMode, </font>
</p>
<p>
<font size="2">	GrOriginLocation_t origin, </font>
</p>
<p>
<font size="2">	FxBool pixelPipeline, </font>
</p>
<p>
<font size="2">	GrLfbInfo_t *info</font>
</p>
<p>
<font size="2">	)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2"><i>type</i>	Lock type.</font>
</p>
<p>
<font size="2">buffer	Buffer to lock.</font>
</p>
<p>
<font size="2"><i>writeMode</i>	Requested destination pixel format.</font>
</p>
<p>
<font size="2"><i>origin	</i>Requested <i>y</i> origin of linear frame buffer.</font>
</p>
<p>
<font size="2"><i>pixelPipeline</i>	If FXTRUE, send linear frame buffer writes through the pixel pipeline.</font>
</p>
<p>
<font size="2"><i>info</i>	Structure to be filled with pointer and stride info.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">When a Glide application desires direct access to a color or auxiliary buffer, it must lock that buffer in order to gain access to a pointer to the frame buffer data. This lock may assert a critical code section which effects process scheduling and preclud
es the use of GUI debuggers; therefore, time spent doing direct accesses should be minimized and the lock should be released as soon as possible using the grLfbUnlock API. An application may hold multiple simultaneous locks to various buffers, depending on
 the underlying hardware. Application software should <i>always</i> check the return value of grLfbLock and take into account the possibility that a lock may fail. </font>
</p>
<p>
<font size="2">A lock type is a bit field created by the bit-wise OR of one read/write flag and an optional idle request flag. The read/write flag can be one of:</font>
</p>
<center><table align="CENTER" width="459" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="305"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFB_READ_ONLY</font>
</p></td>
<td width="305" valign="TOP">
<p>
<font size="2">info.lfbPtr should only be used for read access; writing to this pointer will have undefined effects on the graphics subsystem.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFB_WRITE_ONLY</font>
</p></td>
<td width="305" valign="TOP">
<p>
<font size="2">info.lfbPtr should only be used for write access; reading from this pointer will yield undefined data.</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The idle request flag can be one of:</font>
</p>
<center><table align="CENTER" width="459" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="305"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFB_IDLE</font>
</p></td>
<td width="305" valign="TOP">
<p>
<font size="2">The 3D engine will be idled before grLfbLock returns. This is the default behavior if no idle request flag is specified.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFB_NOIDLE</font>
</p></td>
<td width="305" valign="TOP">
<p>
<font size="2">The 3D engine will not be idled; there is no guarantee of serialization of linear frame buffer accesses and triangle rendering or buffer clearing operations.</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">An application may attempt to lock any Glide buffer. Currently supported buffer designations are GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, and GR_BUFFER_AUXBUFFER.</font>
</p>
<p>
<font size="2">Some 3Dfx hardware supports multiple write formats to the linear frame buffer space. An application may request a particular write format by passing a writeMode argument other than GR_LFBWRITEMODE_ANY. If the destination pixel format specified is not suppo
rted on the target hardware, then the lock will fail. Supported pixels formats are:</font>
</p>
<center><table align="CENTER" width="464" border="1" frame="BOX" rules="ALL">
<colgroup><col width="155"><col width="309"></colgroup><tbody><tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_565</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 16-bit RGB 565 pixel data.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_555</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 16-bit RGB-555 pixel data. The MSB of each pixel is ignored.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_1555</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 16-bit ARGB-1555 pixel data. The alpha component is replicated to 8-bits and copied to the alpha buffer if the alpha buffer has been enabled with grColorMask.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_888</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 24-bit RGB 888 pixel data packed into 32-bit words. The most significant byte of each word is ignored. If dithering is enabled, then color will be dithered down to the real frame buffer storage format if necessary.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_8888</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 32-bit ARGB 8888 pixel data. The alpha component is copied into the alpha buffer if the alpha buffer has been enabled with grColorMask. If dithering is enabled, then color will be dithered down to the real frame buffer storage format i
f necessary.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_565_DEPTH</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 32-bit pixels where the two most significant bytes contain 565 RGB data, and the two least significant bytes contain 16-bit depth data. </font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_555_DEPTH</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 32-bit pixels where the two most significant bytes contain 555 RGB data, the most significant bit is ignored, and the two least significant bytes contain 16-bit depth data.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_1555_DEPTH</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 32-bit pixels where the two most significant bytes contain 1555 ARGB data, the alpha component is replicated to 8-bits and copied to the alpha buffer if alpha buffering has been enabled with grColorMask.</font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_ZA16</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Frame buffer accepts 16-bit auxiliary buffer values. This is the only writeMode that is valid when locking the auxiliary buffer. Alpha buffer values are taken from the 8 least significant bits of each sixteen bit word. </font>
</p></td>
</tr>
<tr>
<td width="155" valign="TOP">
<p>
<font size="2">GR_LFBWRITEMODE_ANY</font>
</p></td>
<td width="309" valign="TOP">
<p>
<font size="2">Lock will return the pixel format that most closely matches the true frame buffer storage format in the info.writeMode.</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">If the application specifies GR_LFB_WRITEMODE_ANY and the lock succeeds, the destination pixel format will be returned in info.writeMode. This default destination pixel format will always be the pixel format that most closely matches the true pixel storage
 format in the frame buffer. On Voodoo Graphics and Voodoo Rush, this will always be GR_LFBWRITEMODE_565 for color buffers and GR_LFBWRITEMODE_ZA16 for the auxiliary buffer. The writeMode argument is ignored for read-only locks. </font>
</p>
<p>
<font size="2">Some 3Dfx hardware supports a user specified <i>y</i> origin for LFB writes. An application may request a particular <i>y</i> origin by passing an origin argument other than GR_ORIGIN_ANY. If the origin specified is not supported on the target hardware, then the lock wi
ll fail. If the application specifies GR_ORIGIN_ANY and the lock succeeds, the LFB <i>y</i> origin will be returned in info.origin. The default <i>y</i> origin will always be GR_ORIGIN_UPPER_LEFT for LFB writes. Currently supported <i>y</i> origin values are:</font>
</p>
<center><table align="CENTER" width="464" border="1" frame="BOX" rules="ALL">
<colgroup><col width="170"><col width="294"></colgroup><tbody><tr>
<td width="170" valign="TOP">
<p>
<font size="2">GR_ORIGIN_UPPER_LEFT</font>
</p></td>
<td width="294" valign="TOP">
<p>
<font size="2">Addressing originates in the upper left hand corner of the screen.</font>
</p></td>
</tr>
<tr>
<td width="170" valign="TOP">
<p>
<font size="2">GR_ORIGIN_LOWER_LEFT</font>
</p></td>
<td width="294" valign="TOP">
<p>
<font size="2">Addressing originates in the lower left hand corner of the screen.</font>
</p></td>
</tr>
<tr>
<td width="170" valign="TOP">
<p>
<font size="2">GR_ORIGIN_ANY</font>
</p></td>
<td width="294" valign="TOP">
<p>
<font size="2">Lock will always choose GR_ORIGIN_UPPER_LEFT</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Some 3Dfx hardware allows linear frame buffer writes to be processed through the same set of functions as those pixels generated by the triangle rasterizer. This feature is enabled by passing a value of FXTRUE in the pixelPipeline argument of grLfbLock. If
 the underlying hardware is incapable of processing pixels through the pixel pipeline, then the lock will fail. When enabled, color, alpha, and depth data from the linear frame buffer write will be processed as if it were generated by the triangle iterator
s. If the selected writeMode lacks depth information, then the value is derived from grLfbConstantDepth. If the writeMode lacks alpha information, then the value is derived from grLfbConstantAlpha. Linear frame buffer writes through the pixel pipeline may 
not be enabled for auxiliary buffer locks. The pixelPipeline argument is ignored for read only locks.</font>
</p>
<p>
<font size="2">An application may not call any Glide routines other than grLfbLock and grLfbUnlock while any lock is active. Any such calls will result in undefined behavior.</font>
</p>
<p>
<font size="2">Upon successful completion, the user provided GrLfbInfo_t structure will be filled in with information pertaining to the locked buffer. The GrLfbInfo_t structure is currently defined as:</font>
</p>
<p>
<font size="2">typedef struct {</font>
</p>
<p>
<font size="2">	int	size;</font>
</p>
<p>
<font size="2">	void	*lfbPtr;</font>
</p>
<p>
<font size="2">	FxU32	strideInBytes;</font>
</p>
<p>
<font size="2">	GrLfbWriteMode_t	writeMode;</font>
</p>
<p>
<font size="2">	GrOriginLocation_t	origin;</font>
</p>
<p>
<font size="2">} GrLfbInfo_t;</font>
</p>
<p>
<font size="2">The size element must be initialized by the user to the size of the GrLfbInfo_t structure, e.g.:</font>
</p>
<p>
<font size="2">info.size = sizeof( GrLfbInfo_t );</font>
</p>
<p>
<font size="2">This size element will be used to provide backward compatibility for future revisions of the API. An unrecognized size will cause the lock to fail. The lfbPtr element is assigned a valid linear pointer to be used for accessing the requested buffer. The str
ideInBytes element is assigned the byte distance between scan lines. </font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The Glide 2.2 release is the first release to include grLfbLock. The following APIs are obsolete in Glide 2.2: grLfbBegin, grLfbEnd, grLfbGetReadPtr, grLfbGetWritePtr, grLfbBypassMode, grLfbWriteMode, and grLfbOrigin.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
See Also
</p>
<p>
<font size="2">grLfbUnlock, grLfbConstantAlpha, grLfbConstantDepth, grLfbReadRegion, grLfbWriteRegion</font>
</p>
<p>
<font size="2"><br></font>
</p>
<h2>
 grLfbReadRegion
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbReadRegion – efficiently copy a pixel rectangle into a linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grLfbReadRegion(	GrBuffer_t src_buffer, </font>
</p>
<p>
<font size="2">	FxU32 src_x, FxU32 src_y, </font>
</p>
<p>
<font size="2">	FxU32 src_width, FxU32 src_height, </font>
</p>
<p>
<font size="2">	FxU32 dst_stride, void *dst_data )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2"><i>src_buffer</i>	Source frame buffer. Valid values are GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, and GR_BUFFER_AUXBUFFER.</font>
</p>
<p>
<font size="2">src_x, src_y	Source <i>x</i> and <i>y</i> coordinates The <i>y</i> origin is always assumed to be at the upper left.</font>
</p>
<p>
<font size="2"><i>src_width</i>, <i>src_height</i>	Width and height of source rectangle to be copied from the frame buffer.</font>
</p>
<p>
<font size="2"><i>dst_stride</i>	Stride, in bytes, of destination user memory buffer.</font>
</p>
<p>
<font size="2"><i>dst_data</i>	Pointer to destination user memory buffer.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">This API copies a rectangle from a region of a frame buffer into a buffer in user memory; this is the only way to read back from the frame buffer on Scanline Interleaved systems. </font>
</p>
<p>
<font size="2">A src_width by src_height rectangle of pixels is copied from the buffer specified by src_buffer, starting at the location (src_x, src_y). The pixels are copied to user memory starting at dst_data, with a stride in bytes defined by dst_stride. </font>
</p>
<p>
<font size="2">The frame buffer <i>y</i> origin is always assumed to be at the upper left. The pixel data read will always be 16-bit 565 RGB.</font>
</p>
<p>
<font size="2">The dst_stride must be greater than or equal to src_width * 2.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The Glide 2.2 release is the first release to include grLfbReadRegion. The following APIs are obsolete in Glide 2.2: grLfbBegin, grLfbEnd, grLfbGetReadPtr, grLfbGetWritePtr, grLfbBypassMode, grLfbWriteMode, and grLfbOrigin.</font>
</p>
<p>
See Also
</p>
<p>
<font size="2">grLfbLock, grLfbUnlock, grLfbConstantAlpha, grLfbConstantDepth, grLfbWriteRegion</font>
</p>
<h2>
grLfbUnlock
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbUnlock – unlock a frame buffer previously locked with grLfbLock.</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grLfbUnlock( GrLock_t type, GrBuffer_t buffer )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2"><i>type</i>	Lock type. Valid values are GR_LFB_READ_ONLY and GR_LFB_WRITE_ONLY.</font>
</p>
<p>
<font size="2">buffer	Buffer to unlock. Valid values are GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, and GR_BUFFER_AUXBUFFER.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">When an application desires direct access to a color or auxiliary buffer, it must lock that buffer in order to gain access to a pointer to the frame buffer data. When the application has completed its direct access transactions and would like restore 3D an
d GUI engine access to the buffer, then it must call grLfbUnlock. It is important to note that after a successful call to grLfbUnlock, accessing the info.lfbPtr used in the grLfbLock call will have undefined results.</font>
</p>
<p>
<font size="2">An application may not call any Glide routines other than grLfbLock and grLfbUnlock while any lock is active.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The Glide 2.2 release is the first release to include grLfbUnlock. The following APIs are obsolete in Glide 2.2: grLfbBegin, grLfbEnd, grLfbGetReadPtr, grLfbGetWritePtr, grLfbBypassMode, grLfbWriteMode, and grLfbOrigin.</font>
</p>
<p>
See Also
</p>
<p>
<font size="2">grLfbLock, grLfbConstantAlpha, grLfbConstantDepth</font>
</p>
<p>
<font size="2"><br></font>
</p>
<h2>
grLfbWriteRegion
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbWriteRegion – efficiently copy a pixel rectangle into a linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grLfbWriteRegion( GrBuffer_t dst_buffer, </font>
</p>
<p>
<font size="2">	FxU32 dst_x, FxU32 dst_y, </font>
</p>
<p>
<font size="2">	GrLfbSrcFmt_t src_format, </font>
</p>
<p>
<font size="2">	FxU32 src_width, FxU32 src_height, </font>
</p>
<p>
<font size="2">	FxU32 src_stride, void *src_data </font>
</p>
<p>
<font size="2">	)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2"><i>dst_buffer</i>	Destination frame buffer. Valid values are GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, and GR_BUFFER_AUXBUFFER.</font>
</p>
<p>
<font size="2">dst_x, dst_y	Destination <i>x</i> and <i>y</i> coordinates The <i>y</i> origin is always assumed to be at the upper left.</font>
</p>
<p>
<font size="2"><i>src_format</i> 	Format of source image.</font>
</p>
<p>
<font size="2"><i>src_width</i>, <i>src_height</i>	Width and height of source image.</font>
</p>
<p>
<font size="2"><i>src_stride</i>	Stride of source image.</font>
</p>
<p>
<font size="2"><i>src_data</i>	Pointer to image data.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">This API copies a rectangle from a region of memory pointed to by src_data into the linear frame buffer as efficiently as possible. The image may be in one of the following source formats:</font>
</p>
<table width="479" frame="VOID" rules="NONE">
<colgroup><col width="179"><col width="300"></colgroup><tbody><tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_565</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 565 color image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_555</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 555 color image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_1555</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 1555 color image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_888</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 888 color image each pixel padded to 32-bits with RGB in low order 24-bits</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_8888</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">ARGB 8888 color image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_565_DEPTH</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 565 and 16-bit depth value packed into each 32-bit element of image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_555_DEPTH</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 555 and 16-bit depth value packed into each 32-bit element of image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_1555_DEPTH</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">RGB 1555 and 16-bit depth value packed into each 32-bit element of image</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_ZA16</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">Two 16-bit depth or alpha values. Alpha values are stored into odd bytes.</font>
</p></td>
</tr>
<tr>
<td width="179" valign="TOP">
<p>
<font size="2">GR_LFB_SRC_FMT_RLE16</font>
</p></td>
<td width="300" valign="TOP">
<p>
<font size="2">16 BPP RLE Encoded image - see notes</font>
</p></td>
</tr>
</tbody></table>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The src_data pointer must point to the starting pixel of the rectangle to be copied. A rectangle in memory defined by src_width, src_height, and src_stride will be copied into the buffer designated by dst_buffer at the location (dst_x, dst_y<i>)</i><i></i>. src_stride i
s defined as bytes per scan line in the source image.</font>
</p>
<p>
<font size="2">The frame buffer <i>y</i> origin is always assumed to be at the upper left.</font>
</p>
<p>
<font size="2">Not all 3Dfx graphics subsystems will support all source image formats. The function will fail if the source format supplied is not supported by the detected 3D hardware.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The GR_LFB_SRC_FMT_RLE16 format is a two-word format consisting of one 16-bit count word and one 16-bit color word. The count word should be treated as a signed 16-bit integer. Negative values are currently ignored. </font>
</p>
<p>
<font size="2">The Glide 2.2 release is the first release to include grLfbWriteRegion. The following APIs are obsolete in Glide 2.2: grLfbBegin, grLfbEnd, grLfbGetReadPtr, grLfbGetWritePtr, grLfbBypassMode, grLfbWriteMode, and grLfbOrigin.</font>
</p>
<p>
See Also
</p>
<p>
<font size="2">grLfbLock, grLfbUnlock, grLfbConstantAlpha, grLfbConstantDepth, grLfbReadRegion</font>
</p>
<p>
<font size="2"><br></font>
</p>
<h2>
grRenderBuffer
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grRenderBuffer – selects the current color buffer for drawing and clearing</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grRenderBuffer( GrBuffer_t buffer )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">buffer	Selects the current color buffer. Valid values are GR_BUFFER_FRONTBUFFER and GR_BUFFER_BACKBUFFER.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grRenderBuffer selects the buffer for primitive drawing and buffer clears. The default is GR_BUFFER_BACKBUFFER.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grBufferClear, grDrawLine, grDrawPoint, grDrawTriangle</font>
</p>
<h2>
grSstControlMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstControlMode – perform SST-1 and SST-96 control functions</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grSstControlMode( GrSstControlMode_t mode)</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The control mode. Valid values are:</font>
</p>
<center><table align="CENTER" width="384" border="1" frame="BOX" rules="ALL">
<colgroup><col width="136"><col width="248"></colgroup><tbody><tr>
<td width="136" valign="TOP">
<p align="CENTER">
<font size="2"><i><b>mode</b></i></font>
</p></td>
<td width="248" valign="TOP">
<p align="CENTER">
<font size="2"><b>Description</b></font>
</p></td>
</tr>
<tr>
<td width="136" valign="TOP">
<p>
<font size="1">GR_CONTROL_ACTIVATE</font>
</p></td>
<td width="248" valign="TOP">
<p>
<font size="2">activate 3D display</font>
</p></td>
</tr>
<tr>
<td width="136" valign="TOP">
<p>
<font size="1">GR_CONTROL_DEACTIVATE</font>
</p></td>
<td width="248" valign="TOP">
<p>
<font size="2">activate 2D display</font>
</p></td>
</tr>
<tr>
<td width="136" valign="TOP">
<p>
<font size="1">GR_CONTROL_RESIZE</font>
</p></td>
<td width="248" valign="TOP">
<p>
<font size="2">resize back buffers and auxiliary buffers <i>(SST-96 only)</i></font>
</p></td>
</tr>
<tr>
<td width="136" valign="TOP">
<p>
<font size="1">GR_CONTROL_MOVE</font>
</p></td>
<td width="248" valign="TOP">
<p>
<font size="2">validate location after window move <i>(SST-96 only)</i></font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstControlMode determines whether the VGA display or Voodoo Graphics display is visible, depending on the value of <i>mode.</i> This routine supersedes the now-obsolete grSstPassthru routine and provides the same functionality for SST-1 hardware; additional fun
ctionality is provided for windowed SST-96 applications. </font>
</p>
<p>
<font size="2">The variable, mode, specifies one of four values. The first two values apply to all systems. When GR_CONTROL_ACTIVATE is specified, the Voodoo Graphics frame buffer will be displayed in full screen mode. On SST-96 systems, the video tile is enabled.</font>
</p>
<p>
<font size="2">If mode is GR_CONTROL_DEACTIVATE, the 2D VGA frame buffer is displayed. On SST-96 systems, the video tile is disabled.</font>
</p>
<p>
<font size="2">GR_CONTROL_RESIZE is ignored under DOS, SST-1, and SST-96 in full screen mode. For windowed Glide applications, this call resizes the back buffers and auxiliary buffers, and is typically made by Win32 applications in response to WM_SIZE messages. The grSst
ControlMode call may fail if there is not enough offscreen video memory to accommodate the resized buffers.</font>
</p>
<p>
<font size="2">GR_CONTROL_MOVE is ignored under DOS, SST-1, and SST-96 in full screen mode. For windowed Glide applications, this call is used to validate the location and clip region associated with the front buffer when the user moves a window, and is typically made by
 Win32 applications in response to WM_MOVE messages. This call may fail if underlying DirectDraw implementation fails.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">On SST-1, since the 3D and 3D graphics exist on different devices (and frame buffers), activating or deactivating pass through does not require you repaint either the 2D or 3D graphics. On the SST-96, the application is responsible for repainting the 2D gr
aphics or 3D graphics when you use GR_CONTROL_ACTIVATE or GR_CONTROL_DEACTIVATE.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<h2>
grSstIdle
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstIdle – returns when the Voodoo Graphics subsystem is idle</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstIdle( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstIdle returns when the Voodoo Graphics subsystem is no longer busy. The system is busy when either the hardware FIFO is not empty or the graphics engine is busy.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstStatus</font>
</p>
<h2>
grSstIsBusy
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstIsBusy – indicates whether or not the Voodoo Graphics subsystem is busy</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grSstIsBusy( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstIsBusy returns FXTRUE if the Voodoo Graphics subsystem is busy; otherwise, it returns FXFALSE. The system is busy when either the hardware FIFO is not empty or the graphics engine is busy.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstIdle, grSstStatus, grSstVRetraceOn</font>
</p>
<p>
<font size="2"><br></font>
</p>
<h2>
grSstOrigin
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstOrigin – establishes a <i>y</i> origin</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstOrigin( GrOriginLocation_t origin )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">origin	Specifies the direction of the <i>y</i> coordinate axis. GR_ORIGIN_UPPER_LEFT places the screen space origin at the upper left corner of the screen with positive <i>y</i> going down. GR_ORIGIN_LOWER_LEFT places the screen space origin at the lower left corner of 
the screen with positive<i> y </i>going up.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstOrigin sets the <i>y</i> origin for all triangle operations, fast fill, and clipping rectangles. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grSstOrigin overrides the <i>y</i> origin specified in grSstWinOpen.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstWinOpen</font>
</p>
<h2>
grSstPerfStats
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstPerfStats – get pixel rendering statistics</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstPerfStats( GrSstPerfStats_t *pStats )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">pStats	Pointer to a structure in which the performance statistics will be returned.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">The Voodoo Graphics hardware maintains a set of five counters that collect statistics about the fate of pixels as they move through the pixel pipeline. Glide provides access to these counters through the GrSstPerfStats_s structure and grSstPerfStats. The f
ollowing information is returned in the structure pointed to by <i>pStats</i>:</font>
</p>
<center><table align="CENTER" width="474" border="1" frame="BOX" rules="ALL">
<colgroup><col width="106"><col width="368"></colgroup><tbody><tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>pStats</b><b><i> </i>field</b></font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2"><b>Description</b></font>
</p></td>
</tr>
<tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>FxU32</b> pixelsIn</font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2">Number of pixels processed</font>
</p></td>
</tr>
<tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>FxU32</b> chromaFail</font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2">Number of pixels not drawn due to chroma-key failure</font>
</p></td>
</tr>
<tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>FxU32</b> zFuncFail</font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2">Number of pixels not drawn due to depth comparison failure</font>
</p></td>
</tr>
<tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>FxU32</b> aFuncFail</font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2">Number of pixels not drawn due to alpha comparison failure.</font>
</p></td>
</tr>
<tr>
<td width="106" valign="TOP">
<p>
<font size="2"><b>FxU32</b> pixelsOut</font>
</p></td>
<td width="368" valign="TOP">
<p>
<font size="2">Number of pixels drawn. Note that this number includes all pixels drawn (i.e. pixels drawn by grBufferClear and LFB writes that have bypassed the pixel pipeline), not just those that have gone through the rendering pipeline. </font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">All five counters are reset whenever grSstResetPerfStats is called. The hardware counters are only 24-bits wide, so regular calls to grSstResetPerfStats are required to avoid overflow. Alternatively, counter overflows can be detected and accounted for with
out calling grSstResetPerfStats.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">In order to account for every pixel counted and saved in pixelsOut, one must use the following equation:</font>
</p>
<p>
<font size="2">	pixelsOut = LFBwritePixels + bufferClearPixels + (pixelsIn – zFuncFail – chromaFail – aFuncFail)</font>
</p>
<p>
<font size="2">bufferClearPixels represents the number of pixels written as a result of calls to grBufferClear and can be calculated as:</font>
</p>
<p>
<font size="2">bufferClearPixels = (# of times the buffer was cleared)* (clip window width) * (clip window height)</font>
</p>
<p>
<font size="2">grSstPerfStats does not wait for the system to be idle, and hence does not include statistics for commands that are still in the FIFO. Call grSstIdle to empty the FIFO.</font>
</p>
<p>
<br>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstResetPerfStats </font>
</p>
<h2>
grSstQueryBoards
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstQueryBoards –	detect and determine the number of 3Dfx Voodoo Graphics subsystems installed in the host system</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grSstQueryBoards( GrHwConfiguration *hwConfig )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">hwConfig	points to a GrHwConfiguration structure where the system’s hardware configuration will be stored.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstQueryBoards determines the number of installed Voodoo Graphics subsystems and stores this number in hwConfig-&gt;num_sst<i>.</i><i></i> No other information is stored in the structure at this time. grSstQueryBoards may be called before grGlideInit. grSstQueryHardware 
can be called after grGlideInit to fill in the rest of the structure.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grSstQueryBoards does not change the state of any hardware, not does it render any graphics.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grSstQueryBoards.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideInit, grSstQueryHardware</font>
</p>
<h2>
grSstQueryHardware
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstQueryHardware –	detect and determine the nature of any 3Dfx Voodoo Graphics subsystems installed in the host system</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grSstQueryHardware( GrHwConfiguration *hwConfig )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">hwConfig	points to a GrHwConfiguration structure where the system’s hardware configuration will be stored.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstQueryHardware determines the system’s Voodoo Graphics hardware configuration, specifically the number of installed Voodoo Graphics subsystems and each of their hardware configurations (memory, scan line interleaving, etc.). If no Voodoo Graphics hardw
are can be found, grSstQueryHardware returns FXFALSE; otherwise it returns FXTRUE.</font>
</p>
<p>
<font size="2">grSstQueryHardware should be called after grGlideInit and before grSstWinOpen.</font>
</p>
<p>
<font size="2">The GrHwConfiguration structure is defined as follows:</font>
</p>
<p>
<font size="1">typedef struct<br>{<br>	int num_sst;</font>
</p>
<p>
<font size="1">	struct {</font>
</p>
<p>
<font size="1">		GrSstType type;	/* Which hardware is it? */</font>
</p>
<p>
<font size="1">		union SstBoard_u {</font>
</p>
<p>
<font size="1">			GrVoodooConfig_t VoodooConfig;</font>
</p>
<p>
<font size="1">			GrSst96Config_t SST96Config;</font>
</p>
<p>
<font size="1">			GrAT3DConfig_t AT3DConfig;</font>
</p>
<p>
<font size="1">		} sstBoard;</font>
</p>
<p>
<font size="1">	} SSTs[MAX_NUM_SST];	/* configuration for each board */<br>} GrHwConfiguration;</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The structure contains mostly information on the configuration of a Voodoo Graphics subsystem. When two Voodoo Graphics subsystems are configured as a single scan-line interleaved system they are viewed by Glide and an application as a single Voodoo Graphi
cs. Note that each Voodoo Graphics has its own private state and texture table. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Refer to glide.h for possible values for hardware types. Current values are:</font>
</p>
<p>
<font size="1">typedef int GrSstType;<br>#define GR_SSTTYPE_VOODOO	0<br>#define GR_SSTTYPE_SST96	1<br>#define GR_SSTTYPE_AT3D	2</font>
</p>
<p>
<font size="1"><br></font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grGlideInit, grSstWinOpen, grSstQueryBoards, grSstSelect</font>
</p>
<h2>
grSstResetPerfStats
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstResetPerfStats – reset the pixel statistics counters</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstResetPerfStats( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstResetPerfStats resets the pixel counters to 0x00.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
grSstPerfStats
</p>
<h2>
grSstScreenHeight
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstScreenHeight – get the height (in pixels) of an SST screen</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grSstScreenHeight( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstScreenHeight returns the height in pixels of the current SST board. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstWinOpen, grSstSelect</font>
</p>
<h2>
grSstScreenWidth
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstScreenWidth – get the width (in pixels) of an SST screen</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grSstScreenWidth( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstScreenWidth returns the width in pixels of the current SST board. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstWinOpen, grSstSelect</font>
</p>
<h2>
grSstSelect
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstSelect – make a Voodoo Graphics subsystem current</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstSelect( int which_sst )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">which_sst	The ordinal number of the Voodoo Graphics subsystem to make current. This value must be between 0 and the number of installed subsystems returned by grSstQueryHardware.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstSelect selects a particular installed Voodoo Graphics subsystem as active. If the value passed is greater than the number of installed Voodoo Graphics subsystems and you are using the debug build of Glide, a run-time error will be generated. If you ar
e using the release build of Glide, undefined behavior will result.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstWinOpen, grSstQueryHardware</font>
</p>
<h2>
grSstStatus
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstStatus – return the value of the graphics status register</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grSstStatus( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstStatus returns the value of the Voodoo Graphics status register. The bits within this register are defined as follows:</font>
</p>
<center><table align="CENTER" width="366" border="1" frame="BOX" rules="ALL">
<colgroup><col width="41"><col width="325"></colgroup><tbody><tr>
<td width="41" valign="TOP">
<p>
<font size="2"><b>Bit</b></font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2"><b>Description</b></font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">5:0</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">PCI FIFO free space (0x3F=FIFO empty) </font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">6</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Vertical retrace (0=vertical retrace active; 1=vertical retrace inactive). </font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">7</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Pixel<i>fx</i> graphics engine busy (0=engine idle; 1=engine busy)</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">8</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">TMU busy (0=engine idle; 1=engine busy)</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">9</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Voodoo Graphics busy (0=idle; 1=busy)</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">11:10</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Displayed buffer (0=buffer 0; 1=buffer 1; 2=auxiliary buffer; 3=reserved)</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">27:12</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Memory FIFO free space (0xFFFF=FIFO empty)</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">30:28</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">Number of swap buffer commands pending</font>
</p></td>
</tr>
<tr>
<td width="41" valign="TOP">
<p>
<font size="2">31</font>
</p></td>
<td width="325" valign="TOP">
<p>
<font size="2">PCI interrupt generated (not implemented)</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstIdle, grSstIsBusy, grSstSelect, grSstVRetraceOn </font>
</p>
<h2>
grSstVideoLine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstVideoLine – returns the current line number of the display beam</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grSstVideoLine( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstVideoLine returns the current line number of the display beam. This number is 0 during vertical retrace and increases as the display beam progresses down the screen.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">There are a small number of video lines that are not displayed at the top of the screen; the vertical backporch. Thus, grSstVideoLine returns a small positive number when the display beam is at the top of the screen; as the beam goes off the bottom of the 
screen, the line number may exceed the number returned by grSstScreenHeight.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grSstVideoLine.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstStatus, grSstVRetraceOn, grSstScreenHeight</font>
</p>
<h2>
grSstVRetraceOn
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstVRetraceOn – return FXTRUE if vertical retrace is active</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool grSstVRetraceOn( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstVRetraceOn returns FXTRUE if the monitor is in vertical retrace; otherwise FXFALSE is returned.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstStatus, grSstVideoLine</font>
</p>
<h2>
grSstWinClose
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstWinClose – close the graphics display device</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grSstWinClose( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grSstWinClose returns the state of Glide to the one following grGlideInit, so that grSstWinOpen can be called with either a different resolution (SST-1 and SST-96), or a different hwnd parameter (SST-96 only). </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstWinOpen, grSstControlMode</font>
</p>
<h2>
grSstWinOpen
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grSstWinOpen – opens the graphics display device</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="1">FxBool grSstWinOpen(	FxU32 hwnd,</font>
</p>
<p>
<font size="1">	GrScreenResolution_t res,<br>	GrScreenRefresh_t ref,<br>	GrColorFormat_t cformat,<br>	GrOriginLocation_t org_loc,<br>	int num_buffers,<br>	int num_aux_buffers </font>
</p>
<p>
<font size="1">	)</font>
</p>
<p>
<font size="1"><br></font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">hwnd	Specifies a handle to the window. The interpretation of this value depends on the system environment. DOS applications must specify NULL. Applications run on SST-1 graphics hardware must specify NULL as well. Win32 full screen applications running on 
a SST-96 system must specify a window handle; a NULL value for hwnd will cause the application’s real window handle (i.e. what is returned by GetActiveWindow) to be used. Since Win32 pure console applications do not have a window handle, they can be used o
nly with SST-1 and a NULL window handle is required. Finally, Glide Win32 applications that run in a window may either specify NULL (if there is only one window), or the correct hwnd, cast to FxU32.</font>
</p>
<center><table align="CENTER" width="314" border="1" frame="BOX" rules="ALL">
<colgroup><col width="148"><col width="166"></colgroup><tbody><tr>
<td width="148" valign="TOP">
<p>
<font size="2"><b>System Environment</b></font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2"><b><i>hwnd</i> value</b></font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">DOS</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">NULL</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">Win32 Full Screen</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">NULL or hwnd</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">Win32 Pure Console</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">NULL (SST-1 only)</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">Win32 Glide Apps</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">NULL or hwnd (SST-96 only)</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">res	Specifies which screen resolution to use. Refer to sst1vid.h for available video resolutions, e.g., 	GR_RESOLUTION_640x480 and GR_RESOLUTION_800x600. In addition, the resolution GR_RESOLUTION_NONE is permitted for the SST-96. This signals Glide to use 
the user specified window (see the hwnd parameter). Specifying GR_RESOLUTION_NONE on an SST-1 system will cause the call to fail.</font>
</p>
<p>
<font size="2">ref	Specifies the refresh rate to use. Refer to sst1vid.h for available video resolutions, e.g., GR_REFRESH_60HZ and GR_REFRESH_72HZ. The ref parameter is ignored when a Win32 application is running in a window (SST-96 systems only).</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">cformat	Specifies the packed color RGBA ordering for linear frame buffer writes and parameters <i>for the following APIs: </i>grBufferClear<i>, </i>grChromakeyValue, grConstantColorValue<i>, and </i>grFogColorValue<i>. </i>The following table illustrates the available formats:</font>
</p>
<center><table align="CENTER" width="314" border="1" frame="BOX" rules="ALL">
<colgroup><col width="148"><col width="166"></colgroup><tbody><tr>
<td width="148" valign="TOP">
<p>
<font size="2"><b>Color Format</b></font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2"><b>Hex Variable Organization</b></font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">GR_COLORFORMAT_RGBA</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">0xRRGGBBAA</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">GR_COLORFORMAT_ARGB</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">0xAARRGGBB</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">GR_COLORFORMAT_BGRA</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">0xBBGGRRAA</font>
</p></td>
</tr>
<tr>
<td width="148" valign="TOP">
<p>
<font size="2">GR_COLORFORMAT_ABGR</font>
</p></td>
<td width="166" valign="TOP">
<p>
<font size="2">0xAABBGGRR</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">org_loc	Specifies the direction of the <i>y</i> coordinate axis. GR_ORIGIN_UPPER_LEFT places the screen space origin at the upper left corner of the screen with positive <i>y</i> going down (a la IBM VGA). GR_ORIGIN_LOWER_LEFT places the screen space origin at the lower
 left corner of the screen with positive<i> y </i>going up (a la SGI GL).</font>
</p>
<p>
<font size="2">num_buffers	Specifies the number of rendering buffers to use. Supported values 2 (double-buffering) or 3 (triple buffering). If there is not enough memory to support the desired resolution (e.g. 800×600 triple buffered on a 2MB system), an error will occur
.</font>
</p>
<p>
<font size="2">num_aux_buffers	Specifies the number of auxiliary buffers required by an application. The auxiliary buffers are used either for depth or alpha buffering. Permitted values are 0 or 1. For full screen applications, this parameter allows both SST-1 and SST-96
 to validate whether the available video memory will support the application’s requirements for color and auxiliary buffers at a specified screen resolution. For a windowed application running on SST-96, this parameter allows an application to run in a lar
ger 3D window if a depth buffer is not necessary (depth and back buffers share the same off-screen video memory).</font>
</p>
<p>
Description
</p>
<p>
<font size="2">grSstWinOpen initializes the graphics to a known state using the given parameters. It supports both SST-1 and SST-96, and either full-screen or windowed operation in the latter. By default all special effects of the hardware (depth buffering, fog, chroma-k
ey, alpha blending, alpha testing, etc.) are disabled and must be individually enabled. All global state constants (chroma-key value, alpha test reference, constant depth value, constant alpha value, etc.) and pixel rendering statistic counters are initial
ized to 0x00. Upon success, a value of FXTRUE is returned; otherwise a value of FXFALSE is returned. If grSstWinOpen is called on an already open window, FXFALSE will be returned. This routine replaces the obsolete grSstOpen call from previous versions of 
Glide.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grSstWinOpen initializes various Glide state variables, including hints. Thus, grHint should be called after grSstWinOpen if you want something other than the default hint settings. </font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstControlMode, grSstQueryHardware, grSstResetPerfStats, grSstWinClose </font>
</p>
<h2>
grTexCalcMemRequired
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexCalcMemRequired – return the texture memory consumed by a texture</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grTexCalcMemRequired(	GrLOD_t smallLod, GrLOD_t largeLod,<br>GrAspectRatio_t aspect, GrTextureFormat_t format )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">smallLod	The smallest LOD in the mipmap.</font>
</p>
<p>
<font size="2">largeLod 	The largest LOD in the mipmap.</font>
</p>
<p>
<font size="2">aspect	Aspect ratio of the mipmap.</font>
</p>
<p>
<font size="2">format	Format of the mipmap.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexCalcMemRequired calculates and returns the amount of memory a mipmap of the specified LOD range, aspect ratio, and format requires. Because of the packing requirements of some texture formats the number returned may reflect padding bytes required for 
the mipmap.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The value returned includes memory for both the even and odd mipmap levels. In the case where a mipmap is split across two TMUs with the even levels in one TMU and the odd levels in the other TMU, use grTexTextureMemRequired to compute the memory requireme
nts of each TMU.</font>
</p>
<p>
<font size="2">It is possible that memory required for a mipmap is less than the sum of the memory required for its individual mipmap levels. When multiple mipmap levels are packed into one mipmap, they will be loaded into contiguous memory. If the levels are loaded indi
vidually, the starting address for each level must be 8-byte aligned.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexTextureMemRequired</font>
</p>
<h2>
grTexClampMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexClampMode – set the texture map clamping/wrapping mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexClampMode( GrChipID_t tmu,<br>GrTextureClampMode_t sClampMode,<br>GrTextureClampMode_t tClampMode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">sClampMode	<i>The new mode for the </i>s<i> direction, either </i><i></i>GR_TEXTURECLAMP_CLAMP or GR_TEXTURECLAMP_WRAP.</font>
</p>
<p>
<font size="2">tClampMode	<i>The new mode for the</i> t<i> direction, either </i><i></i>GR_TEXTURECLAMP_CLAMP or GR_TEXTURECLAMP_WRAP.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexClampMode sets the texture mapping clamping/wrapping mode for both the <i>s</i> and <i>t</i> directions. If <i>wrapping</i> is enabled, then texture maps will tile, i.e. values greater than 255 will wrap around to 0. If <i>clamping</i> is enabled, then texture map indices will b
e clamped to 0 and 255.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Both modes should always be set to GR_TEXTURECLAMP_CLAMP for perspectively projected textures.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexSource</font>
</p>
<h2>
grTexCombine
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexCombine – configure a texture combine unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexCombine( GrChipID_t tmu,<br>GrCombineFunction_t rgb_function,<br>GrCombineFactor_t rgb_factor<br>GrCombineFunction_t alpha_function,<br>GrCombineFactor_t alpha_factor<br>FxBool rgb_invert,<br>FxBool alpha_invert )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">rgb_function	Specifies the function used in texture color generation. Valid parameters are described below:</font>
</p>
<table width="469" border="1" frame="BOX" rules="ALL">
<colgroup><col width="346"><col width="123"></colgroup><tbody><tr>
<td width="346" valign="TOP">
<p>
<font size="2"><b>Combine Function</b></font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><b>Effect</b></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_ZERO</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL_ALPHA</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_OTHER</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º <i>f</i> * <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + (1 – <i>f</i>) * <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_LOCAL</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º (1 – <i>f</i>) * <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="346" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="123" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
</tbody></table>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">rgb_factor	Specifies the scaling factor <i>f</i> used in texture color generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="342" border="1" frame="BOX" rules="ALL">
<colgroup><col width="248"><col width="94"></colgroup><tbody><tr>
<td width="248" valign="TOP">
<p>
<font size="2"><b>Combine Factor</b></font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><b>Scale Factor (<i>f</i>)</b></font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_NONE</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">Unspecified</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ZERO</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_OTHER_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_DETAIL_FACTOR</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">b</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOD_FRACTION</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><br></font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_OTHER_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL_ALPHA</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_DETAIL_FACTOR</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2">1 – b</font>
</p></td>
</tr>
<tr>
<td width="248" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION</font>
</p></td>
<td width="94" valign="TOP">
<p>
<font size="2"><br></font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">alpha_function	Specifies the function used in texture alpha generation. Valid parameters are described below:</font>
</p>
<table width="483" border="1" frame="BOX" rules="ALL">
<colgroup><col width="347"><col width="136"></colgroup><tbody><tr>
<td width="347" valign="TOP">
<p>
<font size="2"><b>Combine Function</b></font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><b>Effect</b></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_ZERO</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_LOCAL_ALPHA</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_OTHER</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)</font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º <i>f</i> * <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + (1 – <i>f</i>) * <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * (<i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL</font>
</p><p>
<font size="2">GR_COMBINE_FUNCTION_BLEND_LOCAL</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p><p>
<font size="2">º (1 – <i>f</i>) * <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="347" valign="TOP">
<p>
<font size="2">GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA</font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><i>f</i> * (– <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>) + <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font></font>
</p></td>
</tr>
</tbody></table>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">alpha_factor	Specifies the scaling factor <i>f</i> used in texture alpha generation. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="342" border="1" frame="BOX" rules="ALL">
<colgroup><col width="253"><col width="89"></colgroup><tbody><tr>
<td width="253" valign="TOP">
<p>
<font size="2"><b>Combine Factor</b></font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><b>Scale Factor (<i>f</i>)</b></font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_NONE</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">Unspecified</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ZERO</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">0</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_OTHER_ALPHA</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOCAL_ALPHA</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_DETAIL_FACTOR</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">b</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_LOD_FRACTION</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><br></font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">1</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_OTHER_ALPHA</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOCAL_ALPHA</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">1 – <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> / 255</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_DETAIL_FACTOR</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2">1 – b</font>
</p></td>
</tr>
<tr>
<td width="253" valign="TOP">
<p>
<font size="2">GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION</font>
</p></td>
<td width="89" valign="TOP">
<p>
<font size="2"><br></font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">rgb_invert	Specifies whether the generated texture color should be bitwise inverted as a final step.</font>
</p>
<p>
<font size="2">alpha_invert	Specifies whether the generated texture alpha should be bitwise inverted as a final step.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexCombine configures the color and alpha texture combine units of the Voodoo Graphics hardware pipeline. This provides a low level mechanism for controlling all the modes of the texture combine unit without manipulating individual register bits.</font>
</p>
<p>
<font size="2">The texture combine unit computes the function specified by the <i>rgb_function</i> and <i>alpha_function</i> combining functions and the <i>rgb_factor</i> and <i>alpha_factor</i> scale factors on the local filtered texel (<i>C<sub>local </sub></i><sub></sub>and <i>A<sub>local</sub></i><sub></sub>) and the filtered texel from the upstream T
MU (<i>C<sub>other </sub></i><sub></sub>and <i>A<sub>other</sub></i><sub></sub>). The result is clamped to [0..255], and then a bitwise inversion may be applied, controlled by the <i>rgb_invert</i> and <i>alpha_invert</i> parameters. The final result is then passed downstream, to either another TMU or the Pixel<i>fx</i> chip.</font>
</p>
<p>
<font size="2">In the <i>rgb_factor</i> and <i>alpha_factor</i> tables, b is the detail blend factor which is computed as a function of LOD. See grTexDetailControl for further information.</font>
</p>
<p>
<font size="2">grTexCombine also tracks required vertex parameters for the rendering routines. GR_COMBINE_FACTOR_NONE indicates that no parameters are required; it is functionally equivalent to GR_COMBINE_FACTOR_ZERO.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2"><i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> and <i>A<sub>local</sub></i><sub></sub> are the color components generated by indexing and filtering from the mipmap stored on the selected TMU; <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> and <i>A<sub>other</sub></i><sub></sub> are the incoming color components from the neighboring TMU.</font>
</p>
<p>
<font size="2">Inverting the bits in a color is the same as computing (1.0 – color) for floating point color values in the range [0..1] or (255 – color) for 8-bit color values in the range [0..255].</font>
</p>
<p>
<font size="2">The TMU closest to the Pixel<i>fx</i> chip is GR_TMU0. If a TMU exists upstream from GR_TMU0, it is GR_TMU1. If a TMU exists upstream from GR_TMU1, it is GR_TMU2.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawTriangle, grTexLodBiasValue, grTexDetailControl</font>
</p>
<h2>
grTexDetailControl
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDetailControl – set the detail texturing controls</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDetailControl( GrChipID_t tmu, int lodBias,<br>FxU8 detailScale, float detailMax )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu<i>	</i><i></i>Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">lodBias	Controls where the blending between the two textures begins. This value is an LOD bias value in the range [–32.. +31].</font>
</p>
<p>
<font size="2">detailScale	Controls the steepness of the blend. Values are in the range [0..7] are valid. The scale is computed as 2<i><sup>detailScale</sup></i>.</font>
</p>
<p>
<font size="2">detailMax	Controls the maximum blending that occurs. Values in the range [0.0..1.0] are valid.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">Detail texturing refers to the effect where the blend between two textures in a texture combine unit is a function of the LOD calculated for each pixel. grTexDetailControl controls how the detail blending factor, b, is computed from LOD. The <i>lodBias</i> parame
ter controls where the blending begins, the <i>detailScale</i> parameter controls the steepness of the blend (how fast the detail pops in), and the <i>detailMax</i> parameter controls the maximum blending that occurs. Detail blending factor b is calculated as</font>
</p>
<p align="CENTER">
	b = min( detailMax, max( 0, (lodBias – LOD) &lt;&lt; detailScale ) / 255.0 )
</p>
<p>
<font size="2">where LOD is the calculated LOD before grTexLodBiasValue is added. The detail blending factor is typically used by calling grTexCombine with an rgb_function<i> of </i><i></i>GR_COMBINE_FUNCTION_BLEND and an rgb_factor of GR_COMBINE_FACTOR_DETAIL_FACTOR to compute:</font>
</p>
<p align="CENTER">
	C<i><sub>out</sub></i> = b*detail_texture + (1 – b)*main_texture
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">An LOD of <i>n</i> is calculated when a pixel covers approximately 2<i><sup>2n</sup></i> texels. For example, when a pixel covers approximately 1 texel, the LOD is 0. When a pixel covers 4 texels, the LOD is 1, and when a pixel covers 16 texels, the LOD is 2.</font>
</p>
<p>
<font size="2">Detail blending occurs in the downstream TMU. Since the detail texture and main texture typically have very different computed LODs, the detail texturing control settings depend on which texture is in the downstream TMU.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexCombine, grTexLodBiasValue</font>
</p>
<h2>
grTexDownloadMipMap
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDownloadMipMap – download a complete mipmap to texture memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDownloadMipMap( GrChipID_t tmu, FxU32 startAddress,<br>FxU32 evenOdd, GrTexInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">startAddress	Offset into texture memory where the texture will be loaded.</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels to download. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">info	Format, dimensions, and image data for texture.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexDownloadMipMap downloads an entire mipmap to an area of texture memory specified by startAddress. Valid values for startAddress must be between the values returned by grTexMinAddress and grTexMaxAddress and must be 8-byte aligned. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadMipMapLevel, grTexMinAddress, grTexMaxAddress, grTexTextureMemRequired, grTexSource</font>
</p>
<h2>
<a name="GRTEXDOWNLOADMIPMAPLEVEL"></a>grTexDownloadMipMapLevel
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDownloadMipMapLevel – download a single mipmap level to texture memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDownloadMipMapLevel( GrChipID_t tmu, FxU32 startAddress,<br>GrLOD_t thisLod, GrLOD_t largeLod,<br>GrAspectRatio_t aspectRatio,<br>GrTextureFormat_t format,<br>FxU32 evenOdd, void *data )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">startAddress	Offset into texture memory where the texture will be loaded.</font>
</p>
<p>
<font size="2">thisLod	Constant describing LOD to be downloaded.</font>
</p>
<p>
<font size="2">largeLod	Constant describing largest LOD in the complete mipmap of which thisLod is a part.</font>
</p>
<p>
<font size="2">aspectRatio	Constant describing aspect ratio of texture image.</font>
</p>
<p>
<font size="2">format	Constant describing format of color data in texture image.</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels to download. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">data	Raw texture image data.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexDownloadMipMapLevel downloads a single mipmap level to an area of texture memory specified by startAddress. </font>
</p>
<p>
<font size="2">startAddress must lie between the values returned by grTexMinAddress and grTexMaxAddress and must be 8-byte aligned. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadMipMap, grTexDownloadMipMapLevelPartial, grTexMinAddress, grTexMaxAddress, grTexTextureMemRequired, grTexSource</font>
</p>
<h2>
grTexDownloadMipMapLevelPartial
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDownloadMipMapLevelPartial – download part of a single mipmap level to texture memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDownloadMipMapLevelPartial( 	GrChipID_t tmu, FxU32 startAddress,<br>GrLOD_t thisLod, GrLOD_t largeLod,<br>GrAspectRatio_t aspectRatio,<br>GrTextureFormat_t format,<br>FxU32 evenOdd, void *data,<br>int start, int end )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">startAddress	Starting offset into texture memory for download.</font>
</p>
<p>
<font size="2">thisLod	Constant describing LOD to be downloaded.</font>
</p>
<p>
<font size="2">largeLod	Constant describing largest LOD in the complete mipmap of which thisLod is a part.</font>
</p>
<p>
<font size="2">aspectRatio	Constant describing aspect ratio of texture image.</font>
</p>
<p>
<font size="2">format	Constant describing format of color data in texture image.</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels to download. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">data	Raw texture image data.</font>
</p>
<p>
<font size="2">start, end	Starting and ending rows of the mipmap to download.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexDownloadMipMapLevelPartial downloads part of a single mipmap level to an area of texture memory specified by startAddress. Valid values for startAddress must be between the values returned by grTexMinAddress and grTexMaxAddress and must be 8-byte alig
ned. startAddress should point to the beginning of the mipmap even if the starting row to be downloaded is not the first row in the texture. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">To download one row of the texture, use the same value for start and end.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grTexDownloadMipMapLevelPartial.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadMipMap, grTexDownloadMipMapLevel, grTexMinAddress, grTexMaxAddress, grTexTextureMemRequired, grTexSource</font>
</p>
<h2>
grTexDownloadTable
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDownloadTable – download an NCC table or color palette</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDownloadTable( GrChipID_t tmu, GrTexTable_t type, void *data )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">type	Type of texture table. The valid values are:<br>	GR_TEX_NCC0 - Narrow-channel compression table 0<br>	GR_TEX_NCC1 - Narrow-channel compression table 1<br>	GR_TEX_PALETTE - 256 entry color palette</font>
</p>
<p>
<font size="2">data	Table data, either of type GuNccTable or GuTexPalette.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexDownloadTable downloads either an NCC table or a 256-entry color palette to a TMU. There are two NCC tables and one color palette on each TMU. The color palette is referenced when rendering texture formats GR_TEXFMT_P_8 or GR_TEXFMT_AP_88. One of two 
NCC tables is used when decompressing texture formats GR_TEXFMT_YIQ_422 or GR_TEXFMT_AYIQ_8422. Which NCC table is used for decompression is specified by grTexNCCTable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grTexSource does not download a texture’s table - this must be done separately using grTexDownloadTable.</font>
</p>
<p>
<font size="2">grTexDownloadTable does not download an NCC table if the table address is the same as the last table downloaded. Therefore, if the table’s data has changed, it must be copied to a new address before downloading.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadTablePartial, grTexNCCTable, grTexSource</font>
</p>
<h2>
grTexDownloadTablePartial
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexDownloadTablePartial – download a subset of an NCC table or color palette</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexDownloadTablePartial( GrChipID_t tmu, GrTexTable_t type, void *data,<br>int start, int end )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">type	Type of texture table. Valid values are:<br>	GR_TEX_NCC0 - Narrow-channel compression table 0<br>	GR_TEX_NCC1 - Narrow-channel compression table 1<br>	GR_TEX_PALETTE - 256 entry color palette</font>
</p>
<p>
<font size="2">data	Table data, either of type GuNccTable or GuTexPalette.</font>
</p>
<p>
<font size="2">start, end	Starting and ending entries to download.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexDownloadTablePartial downloads part of an NCC table or a 256-entry color palette to a TMU. Entries from start up to and including end are downloaded. There are two NCC tables and one color palette on each TMU. The color palette is referenced when rend
ering texture formats GR_TEXFMT_P_8 or GR_TEXFMT_AP_88. One of two NCC tables is used when decompressing texture formats GR_TEXFMT_YIQ_422 or GR_TEXFMT_AYIQ_8422. Use grTexNCCTable to select one of the two NCC tables.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">To download one entry, use the same value for start and end.</font>
</p>
<p>
<font size="2">Partial downloads of NCC tables is not supported at this time.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grTexDownloadTablePartial.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadTablePartial, grTexNCCTable, grTexSource</font>
</p>
<h2>
grTexFilterMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexFilterMode – specify the texture minification and magnification filters</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexFilterMode( GrChipID_t tmu,<br>GrTextureFilterMode_t minFilterMode,<br>GrTextureFilterMode_t magFilterMode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">minFilterMode	The minification filter, either GR_TEXTUREFILTER_POINT_SAMPLED or GR_TEXTUREFILTER_BILINEAR.</font>
</p>
<p>
<font size="2">magFilterMode	The magnification filter, either GR_TEXTUREFILTER_POINT_SAMPLED or GR_TEXTUREFILTER_BILINEAR.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexFilterMode specifies the texture filters for minification and magnification. The magnification filter is used when the LOD calculated for a pixel indicates that the pixel covers less than one texel. Otherwise, the minification filter is used.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexSource</font>
</p>
<h2>
grTexLodBiasValue
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexLodBiasValue – set the LOD bias value</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexLodBiasValue( GrChipID_t tmu, float bias )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">bias	<i>The new LOD bias value, a si</i><i></i>gned floating point value in the range [-8..7.75].</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexLodBiasValue changes the current LOD bias value, which allows an application to maintain fine grain control over the effects of mipmapping, specifically when mipmap levels change. The LOD bias value is added to the LOD calculated for a pixel and the r
esult determines which mipmap level to use. Smaller LOD values make increasingly sharper images which may suffer from aliasing and moirè effects. Larger LOD values make increasingly smooth images which may suffer from becoming too blurry. The default LOD b
ias value is 0.0.</font>
</p>
<p>
<font size="2">During some special effects, an LOD bias may help image quality. If an application is not performing texture mapping with trilinear filtering or dithered mipmapping, then an LOD bias of 0.5 generally improves image quality by rounding to the nearest LOD. I
f an application is performing dithered mipmapping (i.e. grTexMipMapMode is GR_MIPMAP_NEAREST_DITHER), then an LOD bias of 0.0 or 0.25 generally improves image quality. An LOD bias value of 0.0 is usually best with trilinear filtering.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The bias parameter is rounded to the nearest quarter increment.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexSource</font>
</p>
<h2>
grTexMinAddress
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexMinAddress – return the lowest start address for texture downloads </font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grTexMinAddress( GrChipID_t tmu )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to query. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexMinAddress returns the lower bound on texture memory addresses for a specific TMU.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexMaxAddress, grTexDownloadMipMap, grTexDownloadMipMapLevel, grTexSource</font>
</p>
<p>
<br>
</p>
<h2>
grTexMaxAddress
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexMaxAddress – return the highest start address for texture downloads </font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grTexMaxAddress( GrChipID_t tmu )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to query. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexMaxAddress returns the upper bound on texture memory addresses for a specific TMU.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The returned address is the highest valid texture start address and is valid only for the smallest mipmap level GR_LOD_1.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexMinAddress, grTexDownloadMipMap, grTexDownloadMipMapLevel, grTexSource</font>
</p>
<p>
<br>
</p>
<h2>
grTexMipMapMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexMipMapMode – set the mipmapping mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexMipMapMode( GrChipID_t tmu, GrMipMapMode_t mode, FxBool lodBlend )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">mode	The new mipmapping mode. Valid values are GR_MIPMAP_DISABLE, GR_MIPMAP_NEAREST, and GR_MIPMAP_NEAREST_DITHER.</font>
</p>
<p>
<font size="2">lodBlend 	FXTRUE enables blending between levels of detail when doing trilinear mipmapping. FXFALSE disables LOD blending.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexMipMapMode sets the mipmapping mode for the Voodoo Graphics hardware. The Voodoo Graphics hardware performs mipmapping with no performance penalty. Either no mipmapping, nearest mipmapping, or nearest dithered mipmapping can be performed. Nearest mipm
apping (GR_MIPMAP_NEAREST) selects the nearest mipmap based on LOD. Dithered nearest mipmapping (GR_MIPMAP_NEAREST_DITHERED) dithers between adjacent mipmap levels to reduce the effects of mipmap banding but without the cost of trilinear filtering with LOD
 blending.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">GR_MIPMAP_NEAREST_DITHERED mode can degrade fill-rate performance by 20-30%. This is not always the case, as it is very application dependent. If this mode is used, performance should be benchmarked to determine the cost of the increased quality.</font>
</p>
<p>
<font size="2">GR_MIPMAP_NEAREST truncates the LOD calculated for each pixel. To round to the nearest LOD, set the LOD bias value to 0.5 with grTexLodBiasValue.</font>
</p>
<p>
<font size="2">GR_MIPMAP_NEAREST should be used when <i>lodBlend</i> is FXTRUE.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexLodBiasValue, grTexSource</font>
</p>
<h2>
grTexMultibase
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexMultibase – enables or disables multibase addressing</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexMultibase( GrChipID_t tmu, FxBool enable )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">enable 	FXTRUE enables multibase addressing, FXFALSE disables multibase addressing.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexMultibase enables or disables multibase addressing. Normally, mipmap levels are stored sequentially in texture memory. Multibase addressing allows mipmap levels to be loaded into different texture memory locations. Multibase addressing must be enabled
 before downloading a multibased texture, and before rendering using a multibased texture. Multibase addressing must be disabled before downloading or rendering from a texture with a single base address.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Use grTexMultibaseAddress to specify the multiple base addresses for a multibased texture.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grTexMultibase.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexMultibaseAddress, grTexSource</font>
</p>
<h2>
grTexMultibaseAddress
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexMultibaseAddress – specify one base address for a multibased texture</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexMultibaseAddress( GrChipID_t tmu, <b><font size="1">GrTexBaseRange_t</font></b> <b><font size="1">range,<br></font></b>FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">range	Which base address to specify. Valid values are GR_TEXBASE_256, GR_TEXBASE_128, GR_TEXBASE_64 and GR_TEXBASE_32_TO_1.</font>
</p>
<p>
<font size="2">startAddress	Starting address in texture memory for texture.</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels reside on this TMU for this texture. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">info	Format and dimensions of the texture.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grTexMultibaseAddress specifies one base address for a texture with multiple base addresses. Normally, mipmap levels are stored sequentially in texture memory. Multibase addressing allows mipmap levels to be loaded into different texture memory locations. 
Four different base addresses are specified for a multibased texture, one for GR_LOD_256, one for GR_LOD_128, one for GR_LOD_64, and one for GR_LOD_32 through GR_LOD_1. In each case, startAddress should point to the texture memory location for the correspo
nding mipmap level.</font>
</p>
<p>
<font size="2">All of the base addresses for a multibased texture should be specified before downloading the texture or rendering from the texture.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">grTexSource does not restore the multiple base addresses for a multibased texture, but does set the base address for mipmap level GR_LOD_256. Therefore, it is not necessary to call grTexMultibaseAddress with a range of GR_TEXBASE_256 after a call to grTexS
ource.</font>
</p>
<p>
<font size="2">If a mipmap does not include some of the larger mipmap levels, then the base addresses associated with these missing levels need not be specified.</font>
</p>
<p>
<font size="2">The Glide 2.1 release was the first release to include grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexMultibase, grTexSource</font>
</p>
<h2>
grTexNCCTable
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexNCCTable – select an NCC table</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexNCCTable( GrChipID_t tmu, GrNCCTable_t table )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">table	NCC table to use for decompressing compressed textures. Valid values are GR_TEXTABLE_NCC0 and GR_TEXTABLE_NCC1.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexNCCTable selects one of the two NCC tables on a TMU as the current source for NCC decompression operations. Before rendering operations commence, the appropriate NCC table should be downloaded using grTexDownloadTable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadTable, grTexSource</font>
</p>
<p>
<br>
</p>
<h2>
grTexSource
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexSource – specify the current texture source for rendering</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grTexSource( GrChipID_t tmu, FxU32 startAddress, <br>FxU32 evenOdd, GrTexInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to modify. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">startAddress	Starting address in texture memory for texture.</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels have been downloaded at startAddress. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">info	Format and dimensions of the new texture.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
<font size="2">grTexSource sets up the area of texture memory that is to be used as a source for subsequent texture mapping operations. The startAddress specified should be the same as the startAddress argument to grTexDownloadMipMap, or the starting address used for the
 largest mipmap level when using grTexDownloadMipMapLevel.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexDownloadMipMap, grTexDownloadMipMapLevel, grTexMinAddress, grTexMaxAddress, grTexTextureMemRequired</font>
</p>
<p>
<br>
</p>
<h2>
grTexTextureMemRequired
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grTexTextureMemRequired – return the texture memory consumed by a texture</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 grTexTextureMemRequired( FxU32 evenOdd, GrTexInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">evenOdd	Which mipmap levels are included: even, odd or both. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">info	Format and dimensions of the texture.</font>
</p>
<p>
<font size="2">description</font>
</p>
<p>
grTexTextureMemRequired calculates and returns the number of bytes required to store a given texture. The number returned may be added to the start address for a texture download to determine the next free location in texture memory. 
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grTexCalcMemRequired, grTexDownloadMipMap, grTexDownloadMipMapLevel, grTexMinAddress, grTexMaxAddress, grTexSource</font>
</p>
<p>
<br>
</p>
<h2>
gu3dfGetInfo
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gu3dfGetInfo – get information about the mipmap stored in a .3DF file</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool gu3dfGetInfo( const char *filename, Gu3dfInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">filename	Name of the .3DF file.</font>
</p>
<p>
<font size="2">info	Pointer to a Gu3dfInfo structure to fill with information about the mipmap.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">gu3dfGetInfo allows an application to determine relevant information about a .3DF file located on disk. The information is assigned to the appropriate member elements of the info structure. The Gu3dfInfo structure is defined in glide.h.</font>
</p>
<p>
<font size="2">After an application has determined the characteristics of a .3DF mipmap, it is responsible for allocating system memory for the mipmap. This pointer is stored in the info®data pointer and used by gu3dfLoad.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">gu3dfLoad</font>
</p>
<h2>
gu3dfLoad
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gu3dfLoad – load a .3DF file into system memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool gu3dfLoad( const char *filename, Gu3dfInfo *info )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">filename	Name of the file to load.</font>
</p>
<p>
<font size="2">info	Pointer to a Gu3dfInfo structure that gu3dfLoad fills in after loading the file.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">gu3dfLoad loads a .3DF file specified by filename into the pointer specified by info®data. gu3dfLoad returns FXTRUE if the file was successfully loaded; otherwise it returns FXFALSE. It is assumed the info structure passed has been appropriately configured
 with a call to gu3dfGetInfo.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">gu3dfGetInfo</font>
</p>
<h2>
guAADrawTriangleWithClip
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gu<b><font size="1">AADrawTriangleWithClip</font></b> – performs 2D clipping on triangle, and draws the resultant polygon with anti-aliasing</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guAADrawTriangleWithClip( const GrVertex *va, const GrVertex *vb, const GrVertex *vc )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">va, vb, vc	Vertices which specify the triangle.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
This routine performs 2D clipping on a triangle, and draws the resultant polygon with grAADrawPolygonVertexList.
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">All edges of the triangle are anti-aliased.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
grAADrawTriangle, grAADrawPolygonVertexList, guDrawTriangleWithClip
</p>
<h2>
guAlphaSource
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">gu<b><font size="1">AlphaSource</font></b> – configure the alpha combine unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guAlphaSource( GrAlphaSourceMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new alpha combine unit mode.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guAlphaSource is a higher level interface to the Voodoo Graphics alpha combine unit than grAlphaCombine. The alpha combine unit has two configurable inputs and one output. The output of the alpha combine unit gets fed into the alpha testing and blending un
its. The selection of the <i>A<font size="1"><sub>local </sub></font></i><font size="1"><sub></sub></font>input is important because it is used in the color combine unit.</font>
</p>
<p>
<font size="2">The following table describes how <i>A<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> and output alpha are computed based on the mode:</font>
</p>
<center><table align="CENTER" width="469" border="1" frame="BOX" rules="ALL">
<colgroup><col width="258"><col width="136"><col width="75"></colgroup><tbody><tr>
<td width="258" valign="TOP">
<p>
<font size="2"><b>mode</b></font>
</p></td>
<td width="136" valign="TOP">
<p>
<font size="2"><b>Alpha Output</b></font>
</p></td>
<td width="75" valign="TOP">
<p>
<font size="2"><b><i>A<font size="1"><sub>local</sub></font></i></b><font size="1"><sub></sub></font></font>
</p></td>
</tr>
<tr>
<td width="258" valign="TOP">
<p>
<font size="2"><font size="1">GR_ALPHASOURCE_CC_ALPHA</font></font>
</p></td>
<td width="136" valign="TOP">
<p>
constant color alpha
</p></td>
<td width="75" valign="TOP">
<p>
constant color alpha
</p></td>
</tr>
<tr>
<td width="258" valign="TOP">
<p>
<font size="2"><font size="1">GR_ALPHASOURCE_ITERATED_ALPHA</font></font>
</p></td>
<td width="136" valign="TOP">
<p>
iterated vertex alpha
</p></td>
<td width="75" valign="TOP">
<p>
iterated vertex alpha
</p></td>
</tr>
<tr>
<td width="258" valign="TOP">
<p>
<font size="2"><font size="1">GR_ALPHASOURCE_TEXTURE_ALPHA</font></font>
</p></td>
<td width="136" valign="TOP">
<p>
texture alpha
</p></td>
<td width="75" valign="TOP">
<p>
none
</p></td>
</tr>
<tr>
<td width="258" valign="TOP">
<p>
<font size="2"><font size="1">GR_ALPHASOURCE_TEXTURE_ALPHA_TIMES_ITERATED_ALPHA</font></font>
</p></td>
<td width="136" valign="TOP">
<p>
texture alpha * iterated alpha
</p></td>
<td width="75" valign="TOP">
<p>
iterated vertex alpha
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Constant color alpha is the value passed to grConstantColorValue.</font>
</p>
<p>
<font size="2">If texture has no alpha component, texture alpha is 255.</font>
</p>
<p>
<font size="2">guAlphaSource is a compatibility layer for grAlphaCombine.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grConstantColorValue, grAlphaCombine, grColorCombine</font>
</p>
<h2>
guColorCombineFunction
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guColorCombineFunction – configure the color combine unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guColorCombineFunction( GrColorCombineFunction_t func )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">func	Specifies the source color generation function. Valid parameters are described below:</font>
</p>
<center><table align="CENTER" width="455" border="1" frame="BOX" rules="ALL">
<colgroup><col width="267"><col width="188"></colgroup><tbody><tr>
<td width="267" valign="TOP">
<p>
<font size="2"><b>Color Combine Function</b></font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2"><b>Effect</b></font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_ZERO</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">0x00 per component</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_ITRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Gouraud shading</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_DECAL_TEXTURE</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_CCRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">flat-shaded texture using constant color (grConstantColorValue) as the shading value</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Gouraud-shaded texture</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB_ADD_ALPHA</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">Gouraud-shaded texture + alpha</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ALPHA</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture * alpha</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_ADD_ITRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture + iterated RGB</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_SUB_ITRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture – iterated RGB</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_CCRGB</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">flat shading using constant color (grConstantColorValue)</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_CCRGB_BLEND_ITRGB_ON_TEXALPHA</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">blend between constant color and iterated RGB using an alpha texture, where alpha of 0 and 1 correspond to constant color and iterated RGB respectively</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_DIFF_SPEC_A</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture * alpha + iterated RGB</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_DIFF_SPEC_B</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">texture * iterated RGB + alpha</font>
</p></td>
</tr>
<tr>
<td width="267" valign="TOP">
<p>
<font size="2">GR_COLORCOMBINE_ONE</font>
</p></td>
<td width="188" valign="TOP">
<p>
<font size="2">0xFF per component</font>
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guColorCombineFunction configures the Voodoo Graphics subsystem’s hardware pipeline in a fashion dictated by the parameter func. This provides a high level mechanism for controlling common rendering modes without manipulating individual registers within th
e hardware. The default color combine function is undefined, so an application must set the color combine function before executing any rendering commands.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_ZERO	Forces the output of the color combine unit to always be black (0x00000000).</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_ITRGB	Uses the iterated RGB values in the GrVertex structure to render a primitive. The effect of this is a smoothly iterated color across the entire face of a triangle.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_DECAL_TEXTURE	</font>
</p>
<p>
<font size="2">Uses the sow and tow values to texture map onto the primitive. The texture color used at each pixel is determined by the value of guTexSource and the current guTexCombineFunction.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_CCRGB	</font>
</p>
<p>
<font size="2">Like GR_COLORCOMBINE_DECAL_TEXTURE, except each texel is multiplied by the constant color value set with grConstantColorValue. This allows for lit flat-shaded texture maps.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB	</font>
</p>
<p>
<font size="2">Like GR_COLORCOMBINE_TEXTURE_TIMES_CCRGB, except each texel is multiplied by the current iterated RGB value. This allows for lit Gouraud-shaded texture maps.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB_ADD_ALPHA	</font>
</p>
<p>
<font size="2">Like GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB, except that the alpha value is added to the product of the texel and the iterated RGB color. This allows for specular highlights on Gouraud-shaded texture maps.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_TIMES_ALPHA	</font>
</p>
<p>
<font size="2">Multiplies each texel by alpha (the <i>local</i> alpha within the alpha combine unit).</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_ADD_ITRGB</font>
</p>
<p>
<font size="2">	Like GR_COLORCOMBINE_DECAL_TEXTURE, except that the current iterated RGB value is added to each texel before it is passed down the pixel pipeline.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_TEXTURE_SUB_ITRGB</font>
</p>
<p>
<font size="2">	Like GR_COLORCOMBINE_DECAL_TEXTURE, except that the current iterated RGB value is subtracted from each texel before it is passed down the pixel pipeline.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_CCRGB	Uses the color specified by grConstantColorValue to render a primitive. This is useful for flat-shaded primitives. This color combine function requires that a color value be packed into a 32-bit color value (in the format specified by
 the cformat argument to grSstWinOpen).</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_CCRGB_BLEND_ITRGB_ON_TEXALPHA</font>
</p>
<p>
<font size="2">	Uses a blend between grConstantColorValue and the current iterated RGB value as the output color. The amount blended between the two colors is determined by the alpha component for the corresponding pixel in the current texture map. If the current texture
 map does not have an alpha component, then the alpha value used will be 0xFF.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_DIFF_SPEC_A</font>
</p>
<p>
<font size="2">	Like GR_COLORCOMBINE_TEXTURE_TIMES_ALPHA, except the iterated RGB is also added to the final color. This allows for colored specular highlights to be added to a white lit texture mapped polygon.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_DIFF_SPEC_A</font>
</p>
<p>
<font size="2">	Like GR_COLORCOMBINE_TEXTURE_TIMES_ITRGB, except that alpha is also added to the final color. This allows for white specular highlights to be added to a colored lit texture mapped polygon.</font>
</p>
<p>
<font size="2">GR_COLORCOMBINE_ONE	Forces the color combine unit to always output white (0xFFFFFFFF).</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grConstantColorValue, grColorCombine, grTexCombine</font>
</p>
<h2>
guDrawTriangleWithClip
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guDrawTriangleWithClip – draw a triangle with 2D clipping.</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guDrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">va, vb, vc	The three vertices of the triangle.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guDrawTriangleWithClip uses Sutherland-Hodgman clipping [SUTH74] to clip the triangle to the rectangle specified by grClipWindow and then draws the resultant polygon.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDrawTriangle</font>
</p>
<h2>
guFbReadRegion
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFbReadRegion – copy a portion of frame buffer memory to system memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guFbReadRegion( int src_x, int src_y, int w, int h,<br>void *dst, const int strideInBytes )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">src_x, src_y	The initial corner of the region to be read. This maps to the lower left corner if the Voodoo Graphics subsystem’s origin mode is GR_ORIGIN_LOWER_LEFT and to the upper left corner if the Voodoo Graphics subsystem’s origin mode is GR_ORIGIN_UPP
ER_LEFT.</font>
</p>
<p>
<font size="2">w, h	Width and height of the region to be copied.</font>
</p>
<p>
<font size="2">dst	Pointer where the contents of the frame buffer are to be stored.</font>
</p>
<p>
<font size="2">strideInBytes	The distance (in bytes) from one scan-line of the destination to the next.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFbReadRegion copies a portion of the buffer selected by grLfbGetReadPtr to system memory. Each pixel will occupy 16-bits of data in the destination buffer. The format of the pixels is 565 RGB for color buffers, the RGB ordering is dependent on the <i>cforma
t</i> specified in grSstWinOpen. When reading the alpha buffer, the 8-bit alpha values are located in bits[7:0] of each 16-bit word. When reading the depth buffer, the format is either fixed point <i>z </i>values or floating point <i>w </i>values depending on the depth buff
ering mode.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">strideInBytes must be a multiple of 2.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferMode, grLfbLock, grLfbReadRegion, grSstWinOpen, guFbWriteRegion</font>
</p>
<h2>
guFbWriteRegion
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFbWriteRegion – copy a portion of system memory to frame buffer memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guFbWriteRegion( int dst_x, int dst_y, int w, int h,<br>const void *src, const int strideInBytes )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">dst_x, dst_y	The starting corner of the region to be written. This maps to the lower left corner if the Voodoo Graphics subsystem’s origin mode is GR_ORIGIN_LOWER_LEFT and to the upper left if it is GR_ORIGIN_UPPER_LEFT.</font>
</p>
<p>
<font size="2">w, h	Width and height of the region to be written.</font>
</p>
<p>
<font size="2">src<i>	Pointer where the source data for the copy is stored. The format of the source data must be identical to that expected for mode.</i><i></i></font>
</p>
<p>
<font size="2">strideInBytes		The distance (in bytes) from one scan-line of the source to the next.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFbWriteRegion copies a portion of system memory to frame buffer memory. The memory size and pixel format of copy is dependent on the linear frame buffer write mode set with grLfbWriteMode. The buffer written to is determined by the last call to grLfbGetW
ritePtr.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">For 16-bit pixel formats, strideInBytes must be a multiple of 2. For 32-bit pixel formats, strideInBytes must be a multiple of 4.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grLfbLock, grLfbWriteRegion, guFbReadRegion</font>
</p>
<h2>
guFogGenerateExp
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFogGenerateExp – generate an exponential fog table</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guFogGenerateExp( <b><font size="1">GrFog_t</font></b> <b><font size="1">fogTable[GR_FOG_TABLE_SIZE],</font></b> <b><font size="1">float</font></b> <b><font size="1">density</font></b> <b><font size="1">)</font></b></font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">fogTable	The array to receive the generated fog table values.</font>
</p>
<p>
<font size="2">density	The fog density, typically between 0.0 and 1.0.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFogGenerateExp generates an exponential fog table according to the equation:</font>
</p>
<p align="CENTER">
<font size="2"><i>e</i><sup>–<i>density</i>*<i>w </i></sup><i></i></font>
</p>
<p>
<font size="2">where <i>w </i>is the eye-space <i>w </i>coordinate associated with the fog table entry. The resulting fog table is copied into fogTable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The fog table is normalized (scaled) such that the last entry is maximum fog (255).</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogMode, grFogTable, guFogGenerateExp2, guFogGenerateLinear, guFogTableIndexToW</font>
</p>
<h2>
guFogGenerateExp2
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFogGenerateExp2 – generate an exponential squared fog table</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guFogGenerateExp2( <b><font size="1">GrFog_t</font></b> <b><font size="1">fogTable[GR_FOG_TABLE_SIZE],</font></b> <b><font size="1">float</font></b> <b><font size="1">density</font></b> <b><font size="1">)</font></b></font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">fogTable	The array to receive the generated fog table values.</font>
</p>
<p>
<font size="2">density	The fog density, typically between 0.0 and 1.0.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFogGenerateExp2 generates an exponential squared fog table according to the equation:</font>
</p>
<p align="CENTER">
<font size="2"><i>e</i><sup>–(<i>density</i>*<i>w</i>)2</sup></font>
</p>
<p>
<font size="2">where <i>w </i>is the eye-space <i>w </i>coordinate associated with the fog table entry. The resulting fog table is copied into fogTable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The fog table is normalized (scaled) such that the last entry is maximum fog (255).</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogMode, grFogTable, guFogGenerateExp, guFogGenerateLinear, guFogTableIndexToW</font>
</p>
<h2>
guFogGenerateLinear
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFogGenerateLinear – generate a linear fog table</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guFogGenerateLinear( <b><font size="1">GrFog_t</font></b> <b><font size="1">fogTable[GR_FOG_TABLE_SIZE],<br>float</font></b> <b><font size="1">nearW,</font></b> <b><font size="1">float</font></b> <b><font size="1">farW</font></b> <b><font size="1">)</font></b></font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">fogTable	The array to receive the generated fog table values.</font>
</p>
<p>
<font size="2">nearW	The eye-space <i>w </i>coordinate where minimum fog exists.</font>
</p>
<p>
<font size="2">farW	The eye-space <i>w </i>coordinate where maximum fog exists. </font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFogGenerateLinear generates a linear (in eye-space) fog table according to the equation </font>
</p>
<p align="CENTER">
<font size="2">(<i>w </i>– nearW)/( farW – nearW)</font>
</p>
<p>
<font size="2">where <i>w </i>is the eye-space <i>w </i>coordinate associated with the fog table entry. The resulting fog table is copied into fogTable.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The fog table is clamped so that all values are between minimum fog (0) and maximum fog (255).</font>
</p>
<p>
<font size="2">guFogGenerateLinear fog is linear in eye-space <i>w,</i> <i>not</i> in screen-space.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogMode, grFogTable, guFogGenerateExp, guFogGenerateExp2, guFogTableIndexToW</font>
</p>
<h2>
guFogTableIndexToW
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guFogTableIndexToW – convert a fog table index to a floating point eye-space <i>w </i>value</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">float guFogTableIndexToW( int i )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">i	The fog table index, between 0 and GR_FOG_TABLE_SIZE.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guFogTableIndexToW returns the floating point eye-space <i>w </i>value associated with entry <i>i</i> in a fog table. Because fog table entries are non-linear in <i>w,</i> it is not straight forward to initialize a fog table. guFogTableIndexToW assists by converting fog table 
indices to eye-space <i>w </i>values.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">guFogTableIndexToW<b> </b>returns the following:</font>
</p>
<p align="CENTER">
<font size="2"><b>pow(2</b>.<b>0</b>, <b>3</b>.<b>0+(double)(i&gt;&gt;2))</b> <b>/</b> <b>(8-(i&amp;3));</b></font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grFogMode, grFogTable, guFogGenerateExp, guFogGenerateExp2, guFogGenerateLinear</font>
</p>
<h2>
guTexAllocateMemory
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexAllocateMemory – allocate texture memory for a mipmap</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">GrMipMapId_t guTexAllocateMemory( 	GrChipID_t tmu,<br>FxU8 evenOddMask,<br>int width, int height,<br>GrTextureFormat_t format,<br>GrMipMapMode_t mmMode,<br>GrLOD_t smallLod, GrLOD_t largeLod,<br>GrAspectRatio_t aspectRatio,<br>GrTextureClampMode_t sClampMode,<br>GrTextureClampMod
e_t tClampMode,<br>GrTextureFilterMode_t minFilterMode,<br>GrTextureFilterMode_t magFilterMode,<br>float lodBias,<br>FxBool lodBlend )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to allocate memory on. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.	</font>
</p>
<p>
<font size="2">evenOddMask	Selects whether odd levels, even levels, or all levels of the mipmap are downloaded. Valid values are GR_MIPMAPLEVELMASK_EVEN, GR_MIPMAPLEVELMASK_ODD, and GR_MIPMAPLEVELMASK_BOTH.</font>
</p>
<p>
<font size="2">width, height	Width and height of the largest mipmap level.</font>
</p>
<p>
<font size="2">format	Format of the texture. Valid values are GR_TEXFMT_RGB_332, GR_TEXFMT_YIQ_422, GR_TEXFMT_ALPHA_8, GR_TEXFMT_INTENSITY_8, GR_TEXFMT_ALPHA_INTENSITY_44, GR_TEXFMT_RGB_565, GR_TEXFMT_ARGB_8332, GR_TEXFMT_ARGB_1555, GR_TEXFMT_ARGB_4444, GR_TEXFMT_AYIQ_84
22, and GR_TEXFMT_ALPHA_INTENSITY_88.</font>
</p>
<p>
<font size="2">mmMode	Type of mipmapping to be performed when this texture is current. Valid values are GR_MIPMAP_DISABLE, GR_MIPMAP_NEAREST, and GR_MIPMAP_NEAREST_DITHER. This value can be overridden by a call to grTexMipMapMode.</font>
</p>
<p>
<font size="2">smallLod, largeLod	LOD values of the smallest and largest LOD levels in the texture. Valid parameters are GR_LOD_256, GR_LOD_128, GR_LOD_64, GR_LOD_32, GR_LOD_16, GR_LOD_8, GR_LOD_4, GR_LOD_2, and GR_LOD_1. The value in the LOD constant determines the size
 of the largest side of the texture. A combination of the largeLod parameter and the aspectRatio parameter determines the size of each of the mipmap levels. For example, a mipmap with largeLod of GR_LOD_64 and aspectRatio of GR_ASPECT_8x1 would have a 64×8
 texture as its largest LOD. If aspectRatio were GR_ASPECT_1x4, an 16×64 texture would be its largest LOD.</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">aspectRatio	Specifies the aspect ratio of the mipmaps as a factor of width to height. For example, a mipmap 256 texels wide by 128 texels tall has an aspect ratio of GR_ASPECT_2x1. Valid values are GR_ASPECT_8x1, GR_ASPECT_4x1, GR_ASPECT_2x1, GR_ASPECT_1x1
, GR_ASPECT_1x2, GR_ASPECT_1x4, and GR_ASPECT_1x8. A combination of this parameter and the LOD parameter smallLod determines the size of each mipmap level.</font>
</p>
<p>
<font size="2">sClampMode, tClampMode</font>
</p>
<p>
<font size="2">	Type of texture clamping to be performed when this texture is current. Clamping can be controlled in both the <i>s </i>and <i>t </i>directions. Valid parameters are GR_TEXTURECLAMP_CLAMP or GR_TEXTURECLAMP_WRAP. Note that these parameters should always be set to GR_TEX
TURECLAMP_CLAMP for projected textures.</font>
</p>
<p>
<font size="2">minFilterMode	Specifies the type of minification filtering to perform. Valid parameters are GR_TEXTUREFILTER_POINT_SAMPLED and GR_TEXTUREFILTER_BILINEAR</font>
</p>
<p>
<font size="2">magFilterMode	Specifies the type of magnification filtering to perform. Valid parameters are GR_TEXTUREFILTER_POINT_SAMPLED and GR_TEXTUREFILTER_BILINEAR.</font>
</p>
<p>
<font size="2">lodBias	Specifies the LOD bias value in the range [-8..7.75] to be used during mipmapping. Smaller values make increasingly sharper images, larger values make increasingly blurrier images. The lodBias parameter is rounded to the nearest quarter increment. 
By default the LOD bias is 0.</font>
</p>
<p>
<font size="2">lodBlend	Specifies whether trilinear filtering is to be performed when this texture is current. Trilinear filtering blends between LOD levels based on LOD fraction, eliminating mipmap banding artifacts. Valid parameters are FXTRUE and FXFALSE.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexAllocateMemory allocates memory on the specified TMUs and returns a handle to the allocated memory. The amount of memory allocated will be enough to hold a mipmap of the given format, LOD ranges, and aspect ratio. If the texture memory can not be allo
cated, a value of GR_NULL_MIPMAP_HANDLE is returned. After the memory has been allocated, individual mipmap levels can be downloaded one at a time using guTexDownloadMipMapLevel, or all mipmaps can be downloaded using guTexDownloadMipMap.</font>
</p>
<p>
<font size="2">Whenever the texture is specified as a source texture, sClampMode, <i>tClampMode</i>, minFilterMode, magFilterMode, and <i>lodBias</i> will automatically take effect.</font>
</p>
<p>
<font size="2"><i>evenOddMask</i> is used to selectively download LOD levels when LOD blending is to be used. Correct usage is to allocate and download the even levels onto one TMU, and the odd levels onto another, both with the <i>lodBlend</i> parameter set to FXTRUE. Then the textur
e combine mode for the lower numbered TMU is set to GR_TEXTURECOMBINE_TRILINEAR_ODD or GR_TEXTURECOMBINE_TRILINEAR_EVEN depending on whether the odd levels or the even levels were downloaded to it.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexGetCurrentMipMap, guTexGetMipMapInfo, guTexSource</font>
</p>
<h2>
guTexChangeAttributes
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexChangeAttributes – change attributes of a mipmap</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxBool guTexChangeAttributes( GrMipMapID_t mmid,<br>int width, int height,<br>GrTextureFormat_t format,<br>GrMipMapMode_t mmMode,<br>GrLOD_t smallLod, GrLOD_t largeLod,<br>GrAspectRatio_t aspectRatio,<br>GrTextureClampMode_t sClampMode,<br>GrTextureClampMode_t tClampMode,<br>GrTe
xtureFilterMode_t minFilterMode,<br>GrTextureFilterMode_t magFilterMode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mmid	Handle of mipmap whose attributes are being changed.</font>
</p>
<p>
<font size="2">width, height	New width and height of the largest mipmap level or –1 if not changed</font>
</p>
<p>
<font size="2">format	New format of the texture or –1 if not changed.</font>
</p>
<p>
<font size="2">mmMode	New type of mipmapping to be performed when this texture is in effect. Valid values are GR_MIPMAP_DISABLE, GR_MIPMAP_NEAREST, and GR_MIPMAP_NEAREST_DITHER. This value can be overridden by a call to grTexMipMapMode.</font>
</p>
<p>
<font size="2">smallLod, largeLod	New LOD values of the smallest and largest LOD levels or –1 if not changed. Valid parameters are GR_LOD_256, GR_LOD_128, GR_LOD_64, GR_LOD_32, GR_LOD_16, GR_LOD_8, GR_LOD_4, GR_LOD_2, and GR_LOD_1. The value of largeLod determines the si
ze of the largest side of the texture. A combination of the largeLod parameter and the aspectRatio parameter determines the size of each of the mipmap levels. For example, a mipmap with largeLod of GR_LOD_64 and aspectRatio of GR_ASPECT_8x1 would have a 64
×8 texture as its largest LOD. If aspectRatio were GR_ASPECT_1x4, an 16×64 texture would be its largest LOD.</font>
</p>
<p>
<font size="2">aspectRatio	New aspect ratio of the mipmap as a factor of width to height or –1 if not changed. For example, a mipmap 256 texels wide by 128 texels tall has an aspect ratio of GR_ASPECT_2x1. Valid values are GR_ASPECT_8x1, GR_ASPECT_4x1, GR_ASPECT_2x1, GR_
ASPECT_1x1, GR_ASPECT_1x2, GR_ASPECT_1x4, and GR_ASPECT_1x8. A combination of this parameter and the LOD parameter smallLod determines the size of each mipmap level.</font>
</p>
<p>
<font size="2">sClampMode	New type of texture clamping to be performed in the <i>s </i>direction or –1 if not changed. Valid parameters are GR_TEXTURECLAMP_CLAMP or GR_TEXTURECLAMP_WRAP.</font>
</p>
<p>
<font size="2">tClampMode	New type of texture clamping to be performed in the <i>t </i>direction or –1 if not changed. Valid parameters are GR_TEXTURECLAMP_CLAMP or GR_TEXTURECLAMP_WRAP.</font>
</p>
<p>
<font size="2">minFilterMode	New type of minification filtering to perform or –1 if not changed. Valid parameters are GR_FILTER_POINT_SAMPLED and GR_FILTER_BILINEAR.</font>
</p>
<p>
<font size="2">magFilterMode	New type of magnification filtering to perform or –1 if not changed. Valid parameters are GR_FILTER_POINT_SAMPLED and GR_FILTER_BILINEAR.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexChangeAttributes changes some of the attributes of a mipmap. This allows a section of texture memory to be reused without resetting all of texture memory. Upon success, FXTRUE is returned, else FXFALSE is returned.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">For projected textures the clamp modes, sClampMode and tClampMode, should always be set to GR_TEXTURECLAMP_CLAMP.</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, or grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory</font>
</p>
<h2>
guTexCombineFunction
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexCombineFunction – configure the texture combine unit on a Texture Mapping Unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guTexCombineFunction( GrChipID_t tmu, GrTextureCombineFnc_t func )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu<i>	</i><i></i>Texture Mapping Unit to configure. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">func	The new texture combine mode.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexCombineFunction specifies the function used when combining textures on a TMU with incoming textures from the neighboring TMU. Texture combining operations allow for interesting effects such as detail and projected texturing as well as the trilinear fi
ltering of LOD blending.</font>
</p>
<p>
<font size="2">The following table describes the available texture combine functions and their effects. <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> represents the color components generated by indexing and filtering from the mipmap stored on the selected TMU and <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> represents the incoming color componen
ts from the neighboring TMU.</font>
</p>
<center><table align="CENTER" width="455" border="1" frame="BOX" rules="ALL">
<colgroup><col width="192"><col width="94"><col width="169"></colgroup><tbody><tr>
<td width="192" valign="TOP">
<p>
<b>Texture Combine Function</b>
</p></td>
<td width="94" valign="TOP">
<p>
<b>Result</b>
</p></td>
<td width="169" valign="TOP">
<p>
<b>Effect</b>
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_ZERO
</p></td>
<td width="94" valign="TOP">
<p>
0
</p></td>
<td width="169" valign="TOP">
<p>
0x00 per component
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_DECAL
</p></td>
<td width="94" valign="TOP">
<p>
<i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>
</p></td>
<td width="169" valign="TOP">
<p>
decal texture
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_OTHER
</p></td>
<td width="94" valign="TOP">
<p>
<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>
</p></td>
<td width="169" valign="TOP">
<p>
pass through
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_ADD
</p></td>
<td width="94" valign="TOP">
<p>
<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> + <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>
</p></td>
<td width="169" valign="TOP">
<p>
additive texture
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_MULTIPLY
</p></td>
<td width="94" valign="TOP">
<p>
<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> * <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> 
</p></td>
<td width="169" valign="TOP">
<p>
modulated texture
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_SUBTRACT
</p></td>
<td width="94" valign="TOP">
<p>
<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> – <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>
</p></td>
<td width="169" valign="TOP">
<p>
subtractive texture
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_DETAIL
</p></td>
<td width="94" valign="TOP">
<p>
blend (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>, <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)
</p></td>
<td width="169" valign="TOP">
<p>
detail textures with detail on selected TMU
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_DETAIL_OTHER
</p></td>
<td width="94" valign="TOP">
<p>
blend (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>, <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)
</p></td>
<td width="169" valign="TOP">
<p>
detail textures with detail on neighboring TMU
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_TRILINEAR_ODD
</p></td>
<td width="94" valign="TOP">
<p>
blend (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>, <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)
</p></td>
<td width="169" valign="TOP">
<p>
LOD blended textures with odd levels on selected TMU
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_TRILINEAR_EVEN
</p></td>
<td width="94" valign="TOP">
<p>
blend (<i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font>, <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font>)
</p></td>
<td width="169" valign="TOP">
<p>
LOD blended textures with even levels on selected TMU
</p></td>
</tr>
<tr>
<td width="192" valign="TOP">
<p>
GR_TEXTURECOMBINE_ONE
</p></td>
<td width="94" valign="TOP">
<p>
255
</p></td>
<td width="169" valign="TOP">
<p>
0xFF per component
</p></td>
</tr>
</tbody></table></center>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">guTexCombineFunction also keeps track of which TMUs require texture coordinates for the rendering routines.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">Many combine functions that simultaneously use both <i>C<font size="1"><sub>local</sub></font></i><font size="1"><sub></sub></font> and <i>C<font size="1"><sub>other</sub></font></i><font size="1"><sub></sub></font> can be computed with two passes on a single TMU system by using the frame buffer to store intermediate results and the alpha blender to combine the two partial results.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine, grColorCombine, grDrawTriangle, grTexCombine, guTexSource</font>
</p>
<h2>
guTexDownloadMipMap
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexDownloadMipMap – download a mipmap to texture memory</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guTexDownloadMipMap( GrMipMapId_t mmid, const void *src,<br>const GuNccTable *nccTable )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mmid	Handle of the mipmap memory accepting the download.</font>
</p>
<p>
<font size="2">src	Pointer to row-major array of pixels of the format, size, and aspect ratio associated with mmid. Mipmap levels are arranged from largest to smallest size.</font>
</p>
<p>
<font size="2">nccTable	Pointer to a Narrow Channel Compression table. This is only valid for 8-bit compressed textures loaded with gu3dfLoad.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexDownloadMipMap downloads an entire mipmap to an area of texture memory previously allocated with guTexAllocateMemory. The data to be downloaded must have the pixel format and aspect ratio associated with mmid.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, and grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexDownloadMipMapLevel, guTexMemReset, guTexSource</font>
</p>
<h2>
guTexDownloadMipMapLevel
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexDownloadMipMapLevel – download one level of a mipmap</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guTexDownloadMipMapLevel( GrMipMapId_t mmid, GrLOD_t lod, const void **src )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mmid	Handle of the mipmap memory accepting the download.</font>
</p>
<p>
<font size="2">lod	LOD level of the mipmap level to download. Valid parameters are GR_LOD_256, GR_LOD_128, GR_LOD_64, GR_LOD_32, GR_LOD_16, GR_LOD_8, GR_LOD_4, GR_LOD_2, and GR_LOD_1. lod must lie between mmid’s smallLod and largeLod LOD levels specified during guTexAllo
cateMemory.</font>
</p>
<p>
<font size="2">src	Pointer to a pointer to row-major array of pixels of the format, size, and aspect ratio associated with mmid and lod.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexDownloadMipMapLevel downloads a single mipmap level within a mipmap to an area of texture memory previously allocated with guTexAllocateMemory and updates *src to point to the next mipmap level. The data to be downloaded must have the pixel format and
 aspect ratio associated with mmid and must be of the correct size for lod.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, and grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexDownloadMipMapLevel, guTexMemReset, guTexSource</font>
</p>
<h2>
guTexGetCurrentMipMap
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexGetCurrentMipMap – return the handle of the current mipmap</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">GrMipMapId_t *guTexGetCurrentMipMap ( GrChipID_t tmu )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to query. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexGetCurrentMipMap returns the handle of the currently active mipmap on a selected TMU. Each TMU has one currently active mipmap. Mipmaps are made current with guTexSource.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexSource, guTexGetMipMapInfo</font>
</p>
<h2>
guTexGetMipMapInfo
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexGetMipMapInfo – return a pointer to a structure containing information about a specific mipmap.</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">GrMipMapInfo *guTexGetMipMapInfo( GrMipMapId_t mmid )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mmid	Handle of the mipmap inquired about.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexGetMipMapInfo allows an application to retrieve information about a mipmap.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexSource, guTexGetCurrentMipMap</font>
</p>
<h2>
guTexMemQueryAvail
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexMemQueryAvail – return the amount of unallocated texture memory on a Texture Mapping Unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">FxU32 guTexMemQueryAvail( <b><font size="1">GrChipID_t</font></b> tmu )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">tmu	Texture Mapping Unit to query. Valid values are GR_TMU0, GR_TMU1, and GR_TMU2.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexMemQueryAvail returns the amount of unallocated texture memory on a TMU. Only memory allocated with guTexAllocateMemory is taken into account.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, and grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexMemReset</font>
</p>
<h2>
guTexMemReset
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexMemReset – free all allocated texture memory for all Texture Mapping Units</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guTexMemReset( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexMemReset frees up all allocated texture memory. This allows for a simple form of texture memory management; all texture memory is allocated at once and then freed en masse. While simple, this form of memory management prevents some of the complexity a
ssociated with standard memory management techniques, such as garbage collection and memory fragmentation and compaction.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, and grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexMemQueryAvail</font>
</p>
<h2>
guTexSource
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">guTexSource – make a mipmap current on its Texture Mapping Unit</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void guTexSource( GrMipMapId_t mmid )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mmid	Handle of the mipmap to make current.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">guTexSource makes current a mipmap for the TMU it resides on. Each TMU has one current mipmap. In systems with multiple TMUs, multiple mipmap sources are combined by the texture combine function and the output of the final combine is passed on to the pixel
 shading pipeline. By default all the TMUs have NULL texture handles associated with them.</font>
</p>
<p>
<font size="2">When a mipmap is made current, all of its attributes take effect. See guTexAllocateMemory and guTexChangeAttributes for a complete listing of texture attributes. Some of these attributes can be temporarily overridden with grTexClampMode, grTexFilterMode, g
rTexLodBiasValue, and grTexMipMapMode. Note, however, that these routines do not change the mipmap’s attribute, only the current mode of the rendering hardware.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">WARNING: do not use in conjunction with grTexMinAddress, grTexMaxAddress, grTexNCCTable, grTexSource, grTexDownloadTable, grTexDownloadMipMapLevel, grTexDownloadMipMap, grTexMultiBase, and grTexMultibaseAddress.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">guTexAllocateMemory, guTexChangeAttributes, grTexClampMode, grTexFilterMode, guTexGetCurrentMipMap, grTexLodBiasValue, grTexMipMapMode</font>
</p>
<h1>
References
</h1>
<p>
FOLE90		Foley, J., A. van Dam, S. Feiner, and J. Hughes, “Computer Graphics”, Addison-Wesley, 				Reading, 1990
</p>
<p>
SUTH74	Sutherland, I. E. and G. W. Hodgman, “Reentrant Polygon Clipping”, <b>CACM</b> 17(1), 32-42
</p>
<p>
WILL83		Williams, L., “Pyramidal Parametrics”, <i>SIGGRAPH 83</i>, 1-11
</p>
<p>
<font size="5"><u>ToDo List</u></font>
</p>
<p>
<u>Edits</u>
</p>
<ul><li>
decide whether user should be instructed to call grLfbBegin/End around LFB read sequences (for SST-96)
</li><li>
grTexDownloadMipMap*, is startAddress the addr of LOD 0 or what?  need to describe info structure
</li><li>
grTexDownloadMipMapLevel: reword “Constant” phrasing
</li><li>
reword all "Voodoo Graphics", generalize (AT3D).
</li><li>
describe (table?) the LFB modes in grLfbWriteMode
</li><li>
guAADrawTriangleWithClip - need a version with edge flags?</li></ul>
<p>
<u>GLIDE bugs (in Track) that will require doc changes</u>
</p>
<ul><li>
need to specify RGBA ordering for LFB writes and reads, also byte/word swaps<br>maybe grLfbWriteOrder and grLfbReadOrder?  Chris wrote these routines</li></ul>
<p>
<u>DONE</u>
</p>
<ul><li>
check all grSstOpen(cFormat) dependencies (grep the source code):<br>	grBufferClear, grChromakeyValue, grFogColorValue, grConstantColorValue
</li><li>
need a routine to download 1 palette entry
</li><li>
lowercase Name sections, uppercase Parameter and end with period, separate gr* and gu* pages
</li><li>
guTexAllocateMemory - does guTexSource set mm_mode? YES
</li><li>
need to rename grTexCombineFunction to gu*
</li><li>
reworded all "incoming"
</li><li>
reworded all references to Texelfx chips, used TMU instead
</li><li>
change all constant references (GR_*) to Codefont</li></ul>
<h2>
grShadeModel
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grShadeModel – selects the current shading model</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grShadeModel( FxU32 shadeMask )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">shadeMask	A bitmask or ORed values selecting the current shading model. </font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grShadeModel selects which parameters are flat-shaded and which parameters are smooth-shaded. Flat-shaded parameters are constant across a primitive; the value is taken from the first vertex in the primitive. Smooth-shaded parameters are iterated across a 
primitive. shadeMask is a bitmask constructed by ORing individual masks from the following table:</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2">The default shading model mask is 0x00: all parameters are smooth-shaded.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">If a vertex parameter is constant across a primitive, it is best to specify the parameter as flat-shaded. This can increase performance, since the parameter data does not have to be copied to each vertex in the primitive: Glide does not have to compute gra
dients for the parameter and transfers less data to the graphics hardware.</font>
</p>
<p>
<font size="2">If a constant color mode is selected with grColorCombine or grAlphaCombine, Glide automatically flat-shades these parameters; it is not necessary to select a flat-shading mode with grShadeModel.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grAlphaCombine<b><font size="2">,</font></b><b><font size="2"></font></b> grColorCombine<b><font size="2">,</font></b><b><font size="2"></font></b> grConstantColorValue<b><font size="2">,</font></b><b><font size="2"></font></b> grDrawLine<b><font size="2">,</font></b><b><font size="2"></font></b> grDrawPoint<b><font size="2">,</font></b><b><font size="2"></font></b> grDrawTriangle</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<h2>
grLfbBegin
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbBegin – enable reads and writes to the linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbBegin( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbBegin informs Glide that reads or writes to the linear frame buffer are enabled. This gives Glide an opportunity to update various internal registers necessary for the proper operation of the linear frame buffer. During the period of linear frame buff
er reads or writes (between calls to grLfbBegin and grLfbEnd), grDepthBiasLevel is ignored.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">No other Glide calls should be made between calls to grLfbBegin and grLfbEnd except Glide utility routines for reading and writing regions of pixels (e.g. guFbReadRegion and guFbWriteRegion).</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBiasLevel, grLfbEnd</font>
</p>
<h2>
grLfbBypassMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbBypassMode – enable/disable linear frame buffer write bypass mode</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbBypassMode( GrLfbBypassMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new linear frame buffer bypass mode, either GR_LFBBYPASS_DISABLE or GR_LFBBYPASS_ENABLE.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbBypassMode allows an application to bypass the entire pixel pipeline (except dithering) during linear frame buffer writes. This is useful when rendering overlays or text directly to the screen and the application does not wish to disable all current e
ffects (such as fog, depth buffering, etc.) individually. Note that if linear frame buffer bypass is enabled then <i>no</i> effects are enabled with the exception of dithering. This includes clipping to the grClipWindow, so an application must be careful not to w
rite outside of the visible display when grLfbBypassMode is enabled. By default, linear frame buffer bypass mode is disabled.	</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The values of grColorMask and grDepthMask are ignored when grLfbBypassMode is enabled.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDisableAllEffects</font>
</p>
<h2>
grLfbEnd
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbEnd – disable reads and writes to the linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbEnd( void )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">none</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbEnd informs Glide that reads and writes to the linear frame buffer are no longer taking place. This gives Glide an opportunity to update various internal registers necessary for the proper operation of normal rendering operations. Note that grDepthBia
sLevel is ignored during LFB writes (i.e. between calls to grLfbBegin and grLfbEnd).</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">No other Glide calls should be made between calls to grLfbBegin and grLfbEnd except Glide utility routines for reading and writing regions of pixels (e.g. guFbReadRegion and guFbWriteRegion).</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBiasLevel<b><font size="2">,</font></b><b><font size="2"></font></b> grLfbBegin</font>
</p>
<h2>
grLfbGetReadPtr
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbGetReadPtr – returns a read-only pointer to part of the linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">const FxU32 *grLfbGetReadPtr( GrBuffer_t buffer )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">buffer	The buffer for which to return a read-only pointer. Valid parameters are: GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, GR_BUFFER_AUXBUFFER, GR_BUFFER_TRIPLEBUFFER, GR_BUFFER_DEPTHBUFFER, and GR_BUFFER_ALPHABUFFER.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbGetReadPtr returns a read-only pointer to part of the frame buffer. This pointer can be used by an application to read data directly out of the frame buffer. All data is read as two 16-bit pixels per 32-bit word. The format of the pixels is 565 RGB fo
r color buffers; the RGB ordering is dependent on the <i>cformat</i> specified in grSstOpen. The default pixel ordering within the 32-bit read is 0xRRRRLLLL, where the left pixel in the pair is in the lower 16-bits of the 32-bit word. When reading the alpha buffe
r, the 8-bit alpha values are located in bits [7:0] and [23:16] of the 32-bit word. When reading the depth buffer, the format of the two 16-bit values is either fixed point <i>z </i>values or floating point <i>w </i>values depending on the depth buffering mode.</font>
</p>
<p>
<font size="2">Refer to the <i>Glide Programming Guide</i> for more information on linear frame buffer reading and writing. </font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The parameters GR_BUFFER_AUXBUFFER, GR_BUFFER_TRIPLEBUFFER, GR_BUFFER_DEPTHBUFFER, and GR_BUFFER_ALPHABUFFER are synonymous as they all share the same memory.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grDepthBufferMode<b><font size="2">,</font></b><b><font size="2"></font></b> grLfbGetWritePtr<b><font size="2">,</font></b><b><font size="2"></font></b> grSstOpen</font>
</p>
<h2>
grLfbGetWritePtr
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbGetWritePtr – returns a writable pointer to part of the linear frame buffer</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void *grLfbGetWritePtr( GrBuffer_t buffer )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">buffer	The buffer for which to return a writable pointer. Valid parameters are: GR_BUFFER_FRONTBUFFER, GR_BUFFER_BACKBUFFER, GR_BUFFER_AUXBUFFER, GR_BUFFER_TRIPLEBUFFER, GR_BUFFER_DEPTHBUFFER, and GR_BUFFER_ALPHABUFFER.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbGetWritePtr returns a writable pointer to part of the frame buffer. This pointer can be used by an application to write data directly to the frame buffer in a format specified by grLfbWriteMode. Refer to the <i>Glide Programming Guide </i>for more informatio
n on linear frame buffer reading and writing.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The parameters GR_BUFFER_AUXBUFFER, GR_BUFFER_TRIPLEBUFFER, GR_BUFFER_DEPTHBUFFER, and GR_BUFFER_ALPHABUFFER are synonymous as they all share the same memory.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grLfbGetReadPtr</font>
</p>
<h2>
grLfbOrigin
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbOrigin – set the origin for linear frame buffer reads and writes</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void *grLfbOrigin( GrOriginLocation_t origin )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">origin<i>	The new origin location, either </i><i></i>GR_ORIGIN_UPPER_LEFT or GR_ORIGIN_LOWER_LEFT.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbOrigin allows the origin for linear frame buffer writes to be set separately from the origin for other rendering operations (drawing points, lines, triangles, and polygons, clearing buffers, etc.). This is useful in cases where images have a different
 origin than graphics primitives, or where different images have different origins.</font>
</p>
<p>
<font size="2">Notes</font>
</p>
<p>
<font size="2">The origin for the drawing routines and all rendering operations except frame buffer accesses is set with the org_loc argument to grSstOpen.</font>
</p>
<p>
<font size="2">See Also</font>
</p>
<p>
<font size="2">grSstOpen</font>
</p>
<h2>
grLfbWriteMode
</h2>
<p>
<font size="2">Name</font>
</p>
<p>
<font size="2">grLfbWriteMode – set the mode for linear frame buffer writes</font>
</p>
<p>
<font size="2">C Specification</font>
</p>
<p>
<font size="2">void grLfbWriteMode( GrLfbWriteMode_t mode )</font>
</p>
<p>
<font size="2">Parameters</font>
</p>
<p>
<font size="2">mode	The new write mode for linear frame buffer writes. Valid modes are GR_LFBWRITEMODE_565, GR_LFBWRITEMODE_555, GR_LFBWRITEMODE_1555, GR_LFBWRITEMODE_888, GR_LFBWRITEMODE_8888, GR_LFBWRITEMODE_565_DEPTH, GR_LFBWRITEMODE_555_DEPTH, GR_LFBWRITEMODE_1555_DE
PTH, GR_LFBWRITEMODE_DEPTH_DEPTH, and GR_LFBWRITEMODE_ALPHA_ALPHA.</font>
</p>
<p>
<font size="2">Description</font>
</p>
<p>
<font size="2">grLfbWriteMode sets the mode for linear frame buffer writes: when an application writes to a pointer retrieved with grLfbGetWritePtr. Refer to the <i>Glide Programming Guide </i>for more information on linear frame buffer reading and writing.</font>
</p>
<p>
Notes
</p>
<p>
See Also
</p>
<p>
<font size="2">grLfbGetWritePtr</font>
</p>
<p>
<font size="2"><br></font>
</p>
<p>
<font size="2"><br></font>
</p>
</body></html>